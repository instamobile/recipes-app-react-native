{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _jsxFileName = \"E:\\\\Users\\\\Nayla\\\\Escritorio\\\\UADEE\\\\Distribuidas desk\\\\SUBASTAPP\\\\node_modules\\\\react-native-snap-carousel\\\\src\\\\carousel\\\\Carousel.js\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { Component } from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport Easing from \"react-native-web/dist/exports/Easing\";\nimport FlatList from \"react-native-web/dist/exports/FlatList\";\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport ScrollView from \"react-native-web/dist/exports/ScrollView\";\nimport View from \"react-native-web/dist/exports/View\";\nimport { ViewPropTypes } from \"react-native-web/dist/index\";\nimport PropTypes from 'prop-types';\nimport shallowCompare from 'react-addons-shallow-compare';\nimport { defaultScrollInterpolator, stackScrollInterpolator, tinderScrollInterpolator, defaultAnimatedStyles, shiftAnimatedStyles, stackAnimatedStyles, tinderAnimatedStyles } from \"../utils/animations\";\nvar IS_IOS = Platform.OS === 'ios';\nvar AnimatedFlatList = FlatList ? Animated.createAnimatedComponent(FlatList) : null;\nvar AnimatedScrollView = Animated.createAnimatedComponent(ScrollView);\nvar IS_RTL = I18nManager.isRTL;\n\nvar Carousel = function (_Component) {\n  _inherits(Carousel, _Component);\n\n  var _super = _createSuper(Carousel);\n\n  function Carousel(props) {\n    var _this;\n\n    _classCallCheck(this, Carousel);\n\n    _this = _super.call(this, props);\n    _this.state = {\n      hideCarousel: true,\n      interpolators: []\n    };\n\n    var initialActiveItem = _this._getFirstItem(props.firstItem);\n\n    _this._activeItem = initialActiveItem;\n    _this._previousActiveItem = initialActiveItem;\n    _this._previousFirstItem = initialActiveItem;\n    _this._previousItemsLength = initialActiveItem;\n    _this._mounted = false;\n    _this._positions = [];\n    _this._currentContentOffset = 0;\n    _this._canFireBeforeCallback = false;\n    _this._canFireCallback = false;\n    _this._scrollOffsetRef = null;\n    _this._onScrollTriggered = true;\n    _this._lastScrollDate = 0;\n    _this._scrollEnabled = props.scrollEnabled !== false;\n    _this._initPositionsAndInterpolators = _this._initPositionsAndInterpolators.bind(_assertThisInitialized(_this));\n    _this._renderItem = _this._renderItem.bind(_assertThisInitialized(_this));\n    _this._onSnap = _this._onSnap.bind(_assertThisInitialized(_this));\n    _this._onLayout = _this._onLayout.bind(_assertThisInitialized(_this));\n    _this._onScroll = _this._onScroll.bind(_assertThisInitialized(_this));\n    _this._onScrollBeginDrag = props.enableSnap ? _this._onScrollBeginDrag.bind(_assertThisInitialized(_this)) : undefined;\n    _this._onScrollEnd = props.enableSnap || props.autoplay ? _this._onScrollEnd.bind(_assertThisInitialized(_this)) : undefined;\n    _this._onScrollEndDrag = !props.enableMomentum ? _this._onScrollEndDrag.bind(_assertThisInitialized(_this)) : undefined;\n    _this._onMomentumScrollEnd = props.enableMomentum ? _this._onMomentumScrollEnd.bind(_assertThisInitialized(_this)) : undefined;\n    _this._onTouchStart = _this._onTouchStart.bind(_assertThisInitialized(_this));\n    _this._onTouchEnd = _this._onTouchEnd.bind(_assertThisInitialized(_this));\n    _this._onTouchRelease = _this._onTouchRelease.bind(_assertThisInitialized(_this));\n    _this._getKeyExtractor = _this._getKeyExtractor.bind(_assertThisInitialized(_this));\n\n    _this._setScrollHandler(props);\n\n    _this._ignoreNextMomentum = false;\n\n    if (!ViewPropTypes) {\n      console.warn('react-native-snap-carousel: It is recommended to use at least version 0.44 of React Native with the plugin');\n    }\n\n    if (!props.vertical && (!props.sliderWidth || !props.itemWidth)) {\n      console.error('react-native-snap-carousel: You need to specify both `sliderWidth` and `itemWidth` for horizontal carousels');\n    }\n\n    if (props.vertical && (!props.sliderHeight || !props.itemHeight)) {\n      console.error('react-native-snap-carousel: You need to specify both `sliderHeight` and `itemHeight` for vertical carousels');\n    }\n\n    if (props.apparitionDelay && !IS_IOS && !props.useScrollView) {\n      console.warn('react-native-snap-carousel: Using `apparitionDelay` on Android is not recommended since it can lead to rendering issues');\n    }\n\n    if (props.customAnimationType || props.customAnimationOptions) {\n      console.warn('react-native-snap-carousel: Props `customAnimationType` and `customAnimationOptions` have been renamed to `activeAnimationType` and `activeAnimationOptions`');\n    }\n\n    if (props.onScrollViewScroll) {\n      console.error('react-native-snap-carousel: Prop `onScrollViewScroll` has been removed. Use `onScroll` instead');\n    }\n\n    return _this;\n  }\n\n  _createClass(Carousel, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      var _this$props = this.props,\n          apparitionDelay = _this$props.apparitionDelay,\n          autoplay = _this$props.autoplay,\n          firstItem = _this$props.firstItem;\n\n      var _firstItem = this._getFirstItem(firstItem);\n\n      var apparitionCallback = function apparitionCallback() {\n        _this2.setState({\n          hideCarousel: false\n        });\n\n        if (autoplay) {\n          _this2.startAutoplay();\n        }\n      };\n\n      this._mounted = true;\n\n      this._initPositionsAndInterpolators();\n\n      requestAnimationFrame(function () {\n        if (!_this2._mounted) {\n          return;\n        }\n\n        _this2._snapToItem(_firstItem, false, false, true, false);\n\n        _this2._hackActiveSlideAnimation(_firstItem, 'start', true);\n\n        if (apparitionDelay) {\n          _this2._apparitionTimeout = setTimeout(function () {\n            apparitionCallback();\n          }, apparitionDelay);\n        } else {\n          apparitionCallback();\n        }\n      });\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps, nextState) {\n      if (this.props.shouldOptimizeUpdates === false) {\n        return true;\n      } else {\n        return shallowCompare(this, nextProps, nextState);\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var interpolators = this.state.interpolators;\n      var _this$props2 = this.props,\n          firstItem = _this$props2.firstItem,\n          itemHeight = _this$props2.itemHeight,\n          itemWidth = _this$props2.itemWidth,\n          scrollEnabled = _this$props2.scrollEnabled,\n          sliderHeight = _this$props2.sliderHeight,\n          sliderWidth = _this$props2.sliderWidth;\n\n      var itemsLength = this._getCustomDataLength(this.props);\n\n      if (!itemsLength) {\n        return;\n      }\n\n      var nextFirstItem = this._getFirstItem(firstItem, this.props);\n\n      var nextActiveItem = this._activeItem || this._activeItem === 0 ? this._activeItem : nextFirstItem;\n      var hasNewSliderWidth = sliderWidth && sliderWidth !== prevProps.sliderWidth;\n      var hasNewSliderHeight = sliderHeight && sliderHeight !== prevProps.sliderHeight;\n      var hasNewItemWidth = itemWidth && itemWidth !== prevProps.itemWidth;\n      var hasNewItemHeight = itemHeight && itemHeight !== prevProps.itemHeight;\n      var hasNewScrollEnabled = scrollEnabled !== prevProps.scrollEnabled;\n\n      if (nextActiveItem > itemsLength - 1) {\n        nextActiveItem = itemsLength - 1;\n      }\n\n      if (hasNewScrollEnabled) {\n        this._setScrollEnabled(scrollEnabled);\n      }\n\n      if (interpolators.length !== itemsLength || hasNewSliderWidth || hasNewSliderHeight || hasNewItemWidth || hasNewItemHeight) {\n        this._activeItem = nextActiveItem;\n        this._previousItemsLength = itemsLength;\n\n        this._initPositionsAndInterpolators(this.props);\n\n        if (this._previousItemsLength > itemsLength) {\n          this._hackActiveSlideAnimation(nextActiveItem, null, true);\n        }\n\n        if (hasNewSliderWidth || hasNewSliderHeight || hasNewItemWidth || hasNewItemHeight) {\n          this._snapToItem(nextActiveItem, false, false, false, false);\n        }\n      } else if (nextFirstItem !== this._previousFirstItem && nextFirstItem !== this._activeItem) {\n        this._activeItem = nextFirstItem;\n        this._previousFirstItem = nextFirstItem;\n\n        this._snapToItem(nextFirstItem, false, true, false, false);\n      }\n\n      if (this.props.onScroll !== prevProps.onScroll) {\n        this._setScrollHandler(this.props);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this._mounted = false;\n      this.stopAutoplay();\n      clearTimeout(this._apparitionTimeout);\n      clearTimeout(this._hackSlideAnimationTimeout);\n      clearTimeout(this._enableAutoplayTimeout);\n      clearTimeout(this._autoplayTimeout);\n      clearTimeout(this._snapNoMomentumTimeout);\n      clearTimeout(this._edgeItemTimeout);\n      clearTimeout(this._lockScrollTimeout);\n    }\n  }, {\n    key: \"realIndex\",\n    get: function get() {\n      return this._activeItem;\n    }\n  }, {\n    key: \"currentIndex\",\n    get: function get() {\n      return this._getDataIndex(this._activeItem);\n    }\n  }, {\n    key: \"currentScrollPosition\",\n    get: function get() {\n      return this._currentContentOffset;\n    }\n  }, {\n    key: \"_setScrollHandler\",\n    value: function _setScrollHandler(props) {\n      var scrollEventConfig = {\n        listener: this._onScroll,\n        useNativeDriver: true\n      };\n      this._scrollPos = new Animated.Value(0);\n      var argMapping = props.vertical ? [{\n        nativeEvent: {\n          contentOffset: {\n            y: this._scrollPos\n          }\n        }\n      }] : [{\n        nativeEvent: {\n          contentOffset: {\n            x: this._scrollPos\n          }\n        }\n      }];\n\n      if (props.onScroll && Array.isArray(props.onScroll._argMapping)) {\n        argMapping.pop();\n\n        var _props$onScroll$_argM = _slicedToArray(props.onScroll._argMapping, 1),\n            argMap = _props$onScroll$_argM[0];\n\n        if (argMap && argMap.nativeEvent && argMap.nativeEvent.contentOffset) {\n          this._scrollPos = argMap.nativeEvent.contentOffset.x || argMap.nativeEvent.contentOffset.y || this._scrollPos;\n        }\n\n        argMapping.push.apply(argMapping, _toConsumableArray(props.onScroll._argMapping));\n      }\n\n      this._onScrollHandler = Animated.event(argMapping, scrollEventConfig);\n    }\n  }, {\n    key: \"_needsScrollView\",\n    value: function _needsScrollView() {\n      var useScrollView = this.props.useScrollView;\n      return useScrollView || !AnimatedFlatList || this._shouldUseStackLayout() || this._shouldUseTinderLayout();\n    }\n  }, {\n    key: \"_needsRTLAdaptations\",\n    value: function _needsRTLAdaptations() {\n      var vertical = this.props.vertical;\n      return IS_RTL && !IS_IOS && !vertical;\n    }\n  }, {\n    key: \"_canLockScroll\",\n    value: function _canLockScroll() {\n      var _this$props3 = this.props,\n          scrollEnabled = _this$props3.scrollEnabled,\n          enableMomentum = _this$props3.enableMomentum,\n          lockScrollWhileSnapping = _this$props3.lockScrollWhileSnapping;\n      return scrollEnabled && !enableMomentum && lockScrollWhileSnapping;\n    }\n  }, {\n    key: \"_enableLoop\",\n    value: function _enableLoop() {\n      var _this$props4 = this.props,\n          data = _this$props4.data,\n          enableSnap = _this$props4.enableSnap,\n          loop = _this$props4.loop;\n      return enableSnap && loop && data && data.length && data.length > 1;\n    }\n  }, {\n    key: \"_shouldAnimateSlides\",\n    value: function _shouldAnimateSlides() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var inactiveSlideOpacity = props.inactiveSlideOpacity,\n          inactiveSlideScale = props.inactiveSlideScale,\n          scrollInterpolator = props.scrollInterpolator,\n          slideInterpolatedStyle = props.slideInterpolatedStyle;\n      return inactiveSlideOpacity < 1 || inactiveSlideScale < 1 || !!scrollInterpolator || !!slideInterpolatedStyle || this._shouldUseShiftLayout() || this._shouldUseStackLayout() || this._shouldUseTinderLayout();\n    }\n  }, {\n    key: \"_shouldUseCustomAnimation\",\n    value: function _shouldUseCustomAnimation() {\n      var activeAnimationOptions = this.props.activeAnimationOptions;\n      return !!activeAnimationOptions && !this._shouldUseStackLayout() && !this._shouldUseTinderLayout();\n    }\n  }, {\n    key: \"_shouldUseShiftLayout\",\n    value: function _shouldUseShiftLayout() {\n      var _this$props5 = this.props,\n          inactiveSlideShift = _this$props5.inactiveSlideShift,\n          layout = _this$props5.layout;\n      return layout === 'default' && inactiveSlideShift !== 0;\n    }\n  }, {\n    key: \"_shouldUseStackLayout\",\n    value: function _shouldUseStackLayout() {\n      return this.props.layout === 'stack';\n    }\n  }, {\n    key: \"_shouldUseTinderLayout\",\n    value: function _shouldUseTinderLayout() {\n      return this.props.layout === 'tinder';\n    }\n  }, {\n    key: \"_getCustomData\",\n    value: function _getCustomData() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var data = props.data,\n          loopClonesPerSide = props.loopClonesPerSide;\n      var dataLength = data && data.length;\n\n      if (!dataLength) {\n        return [];\n      }\n\n      if (!this._enableLoop()) {\n        return data;\n      }\n\n      var previousItems = [];\n      var nextItems = [];\n\n      if (loopClonesPerSide > dataLength) {\n        var _previousItems2, _nextItems2;\n\n        var dataMultiplier = Math.floor(loopClonesPerSide / dataLength);\n        var remainder = loopClonesPerSide % dataLength;\n\n        for (var i = 0; i < dataMultiplier; i++) {\n          var _previousItems, _nextItems;\n\n          (_previousItems = previousItems).push.apply(_previousItems, _toConsumableArray(data));\n\n          (_nextItems = nextItems).push.apply(_nextItems, _toConsumableArray(data));\n        }\n\n        (_previousItems2 = previousItems).unshift.apply(_previousItems2, _toConsumableArray(data.slice(-remainder)));\n\n        (_nextItems2 = nextItems).push.apply(_nextItems2, _toConsumableArray(data.slice(0, remainder)));\n      } else {\n        previousItems = data.slice(-loopClonesPerSide);\n        nextItems = data.slice(0, loopClonesPerSide);\n      }\n\n      return previousItems.concat(data, nextItems);\n    }\n  }, {\n    key: \"_getCustomDataLength\",\n    value: function _getCustomDataLength() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var data = props.data,\n          loopClonesPerSide = props.loopClonesPerSide;\n      var dataLength = data && data.length;\n\n      if (!dataLength) {\n        return 0;\n      }\n\n      return this._enableLoop() ? dataLength + 2 * loopClonesPerSide : dataLength;\n    }\n  }, {\n    key: \"_getCustomIndex\",\n    value: function _getCustomIndex(index) {\n      var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props;\n\n      var itemsLength = this._getCustomDataLength(props);\n\n      if (!itemsLength || !index && index !== 0) {\n        return 0;\n      }\n\n      return this._needsRTLAdaptations() ? itemsLength - index - 1 : index;\n    }\n  }, {\n    key: \"_getDataIndex\",\n    value: function _getDataIndex(index) {\n      var _this$props6 = this.props,\n          data = _this$props6.data,\n          loopClonesPerSide = _this$props6.loopClonesPerSide;\n      var dataLength = data && data.length;\n\n      if (!this._enableLoop() || !dataLength) {\n        return index;\n      }\n\n      if (index >= dataLength + loopClonesPerSide) {\n        return loopClonesPerSide > dataLength ? (index - loopClonesPerSide) % dataLength : index - dataLength - loopClonesPerSide;\n      } else if (index < loopClonesPerSide) {\n        if (loopClonesPerSide > dataLength) {\n          var baseDataIndexes = [];\n          var dataIndexes = [];\n          var dataMultiplier = Math.floor(loopClonesPerSide / dataLength);\n          var remainder = loopClonesPerSide % dataLength;\n\n          for (var i = 0; i < dataLength; i++) {\n            baseDataIndexes.push(i);\n          }\n\n          for (var j = 0; j < dataMultiplier; j++) {\n            dataIndexes.push.apply(dataIndexes, baseDataIndexes);\n          }\n\n          dataIndexes.unshift.apply(dataIndexes, _toConsumableArray(baseDataIndexes.slice(-remainder)));\n          return dataIndexes[index];\n        } else {\n          return index + dataLength - loopClonesPerSide;\n        }\n      } else {\n        return index - loopClonesPerSide;\n      }\n    }\n  }, {\n    key: \"_getPositionIndex\",\n    value: function _getPositionIndex(index) {\n      var _this$props7 = this.props,\n          loop = _this$props7.loop,\n          loopClonesPerSide = _this$props7.loopClonesPerSide;\n      return loop ? index + loopClonesPerSide : index;\n    }\n  }, {\n    key: \"_getFirstItem\",\n    value: function _getFirstItem(index) {\n      var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props;\n      var loopClonesPerSide = props.loopClonesPerSide;\n\n      var itemsLength = this._getCustomDataLength(props);\n\n      if (!itemsLength || index > itemsLength - 1 || index < 0) {\n        return 0;\n      }\n\n      return this._enableLoop() ? index + loopClonesPerSide : index;\n    }\n  }, {\n    key: \"_getWrappedRef\",\n    value: function _getWrappedRef() {\n      if (this._carouselRef && (this._needsScrollView() && this._carouselRef.scrollTo || !this._needsScrollView() && this._carouselRef.scrollToOffset)) {\n        return this._carouselRef;\n      }\n\n      return this._carouselRef && this._carouselRef.getNode && this._carouselRef.getNode();\n    }\n  }, {\n    key: \"_getScrollEnabled\",\n    value: function _getScrollEnabled() {\n      return this._scrollEnabled;\n    }\n  }, {\n    key: \"_setScrollEnabled\",\n    value: function _setScrollEnabled() {\n      var scrollEnabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      var wrappedRef = this._getWrappedRef();\n\n      if (!wrappedRef || !wrappedRef.setNativeProps) {\n        return;\n      }\n\n      wrappedRef.setNativeProps({\n        scrollEnabled: scrollEnabled\n      });\n      this._scrollEnabled = scrollEnabled;\n    }\n  }, {\n    key: \"_getKeyExtractor\",\n    value: function _getKeyExtractor(item, index) {\n      return this._needsScrollView() ? \"scrollview-item-\" + index : \"flatlist-item-\" + index;\n    }\n  }, {\n    key: \"_getScrollOffset\",\n    value: function _getScrollOffset(event) {\n      var vertical = this.props.vertical;\n      return event && event.nativeEvent && event.nativeEvent.contentOffset && event.nativeEvent.contentOffset[vertical ? 'y' : 'x'] || 0;\n    }\n  }, {\n    key: \"_getContainerInnerMargin\",\n    value: function _getContainerInnerMargin() {\n      var opposite = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var _this$props8 = this.props,\n          sliderWidth = _this$props8.sliderWidth,\n          sliderHeight = _this$props8.sliderHeight,\n          itemWidth = _this$props8.itemWidth,\n          itemHeight = _this$props8.itemHeight,\n          vertical = _this$props8.vertical,\n          activeSlideAlignment = _this$props8.activeSlideAlignment;\n\n      if (activeSlideAlignment === 'start' && !opposite || activeSlideAlignment === 'end' && opposite) {\n        return 0;\n      } else if (activeSlideAlignment === 'end' && !opposite || activeSlideAlignment === 'start' && opposite) {\n        return vertical ? sliderHeight - itemHeight : sliderWidth - itemWidth;\n      } else {\n        return vertical ? (sliderHeight - itemHeight) / 2 : (sliderWidth - itemWidth) / 2;\n      }\n    }\n  }, {\n    key: \"_getViewportOffset\",\n    value: function _getViewportOffset() {\n      var _this$props9 = this.props,\n          sliderWidth = _this$props9.sliderWidth,\n          sliderHeight = _this$props9.sliderHeight,\n          itemWidth = _this$props9.itemWidth,\n          itemHeight = _this$props9.itemHeight,\n          vertical = _this$props9.vertical,\n          activeSlideAlignment = _this$props9.activeSlideAlignment;\n\n      if (activeSlideAlignment === 'start') {\n        return vertical ? itemHeight / 2 : itemWidth / 2;\n      } else if (activeSlideAlignment === 'end') {\n        return vertical ? sliderHeight - itemHeight / 2 : sliderWidth - itemWidth / 2;\n      } else {\n        return vertical ? sliderHeight / 2 : sliderWidth / 2;\n      }\n    }\n  }, {\n    key: \"_getCenter\",\n    value: function _getCenter(offset) {\n      return offset + this._getViewportOffset() - this._getContainerInnerMargin();\n    }\n  }, {\n    key: \"_getActiveItem\",\n    value: function _getActiveItem(offset) {\n      var _this$props10 = this.props,\n          activeSlideOffset = _this$props10.activeSlideOffset,\n          swipeThreshold = _this$props10.swipeThreshold;\n\n      var center = this._getCenter(offset);\n\n      var centerOffset = activeSlideOffset || swipeThreshold;\n\n      for (var i = 0; i < this._positions.length; i++) {\n        var _this$_positions$i = this._positions[i],\n            start = _this$_positions$i.start,\n            end = _this$_positions$i.end;\n\n        if (center + centerOffset >= start && center - centerOffset <= end) {\n          return i;\n        }\n      }\n\n      var lastIndex = this._positions.length - 1;\n\n      if (this._positions[lastIndex] && center - centerOffset > this._positions[lastIndex].end) {\n        return lastIndex;\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"_initPositionsAndInterpolators\",\n    value: function _initPositionsAndInterpolators() {\n      var _this3 = this;\n\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var data = props.data,\n          itemWidth = props.itemWidth,\n          itemHeight = props.itemHeight,\n          scrollInterpolator = props.scrollInterpolator,\n          vertical = props.vertical;\n      var sizeRef = vertical ? itemHeight : itemWidth;\n\n      if (!data || !data.length) {\n        return;\n      }\n\n      var interpolators = [];\n      this._positions = [];\n\n      this._getCustomData(props).forEach(function (itemData, index) {\n        var _index = _this3._getCustomIndex(index, props);\n\n        var animatedValue;\n        _this3._positions[index] = {\n          start: index * sizeRef,\n          end: index * sizeRef + sizeRef\n        };\n\n        if (!_this3._shouldAnimateSlides(props)) {\n          animatedValue = new Animated.Value(1);\n        } else if (_this3._shouldUseCustomAnimation()) {\n          animatedValue = new Animated.Value(_index === _this3._activeItem ? 1 : 0);\n        } else {\n          var interpolator;\n\n          if (scrollInterpolator) {\n            interpolator = scrollInterpolator(_index, props);\n          } else if (_this3._shouldUseStackLayout()) {\n            interpolator = stackScrollInterpolator(_index, props);\n          } else if (_this3._shouldUseTinderLayout()) {\n            interpolator = tinderScrollInterpolator(_index, props);\n          }\n\n          if (!interpolator || !interpolator.inputRange || !interpolator.outputRange) {\n            interpolator = defaultScrollInterpolator(_index, props);\n          }\n\n          animatedValue = _this3._scrollPos.interpolate(_objectSpread(_objectSpread({}, interpolator), {}, {\n            extrapolate: 'clamp'\n          }));\n        }\n\n        interpolators.push(animatedValue);\n      });\n\n      this.setState({\n        interpolators: interpolators\n      });\n    }\n  }, {\n    key: \"_getSlideAnimation\",\n    value: function _getSlideAnimation(index, toValue) {\n      var interpolators = this.state.interpolators;\n      var _this$props11 = this.props,\n          activeAnimationType = _this$props11.activeAnimationType,\n          activeAnimationOptions = _this$props11.activeAnimationOptions;\n      var animatedValue = interpolators && interpolators[index];\n\n      if (!animatedValue && animatedValue !== 0) {\n        return null;\n      }\n\n      var animationCommonOptions = _objectSpread(_objectSpread({\n        isInteraction: false,\n        useNativeDriver: true\n      }, activeAnimationOptions), {}, {\n        toValue: toValue\n      });\n\n      return Animated.parallel([Animated['timing'](animatedValue, _objectSpread(_objectSpread({}, animationCommonOptions), {}, {\n        easing: Easing.linear\n      })), Animated[activeAnimationType](animatedValue, _objectSpread({}, animationCommonOptions))]);\n    }\n  }, {\n    key: \"_playCustomSlideAnimation\",\n    value: function _playCustomSlideAnimation(current, next) {\n      var interpolators = this.state.interpolators;\n\n      var itemsLength = this._getCustomDataLength();\n\n      var _currentIndex = this._getCustomIndex(current);\n\n      var _currentDataIndex = this._getDataIndex(_currentIndex);\n\n      var _nextIndex = this._getCustomIndex(next);\n\n      var _nextDataIndex = this._getDataIndex(_nextIndex);\n\n      var animations = [];\n\n      if (this._enableLoop()) {\n        for (var i = 0; i < itemsLength; i++) {\n          if (this._getDataIndex(i) === _currentDataIndex && interpolators[i]) {\n            animations.push(this._getSlideAnimation(i, 0));\n          } else if (this._getDataIndex(i) === _nextDataIndex && interpolators[i]) {\n            animations.push(this._getSlideAnimation(i, 1));\n          }\n        }\n      } else {\n        if (interpolators[current]) {\n          animations.push(this._getSlideAnimation(current, 0));\n        }\n\n        if (interpolators[next]) {\n          animations.push(this._getSlideAnimation(next, 1));\n        }\n      }\n\n      Animated.parallel(animations, {\n        stopTogether: false\n      }).start();\n    }\n  }, {\n    key: \"_hackActiveSlideAnimation\",\n    value: function _hackActiveSlideAnimation(index, goTo) {\n      var _this4 = this;\n\n      var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var data = this.props.data;\n\n      if (!this._mounted || !this._carouselRef || !this._positions[index] || !force && this._enableLoop()) {\n        return;\n      }\n\n      var offset = this._positions[index] && this._positions[index].start;\n\n      if (!offset && offset !== 0) {\n        return;\n      }\n\n      var itemsLength = data && data.length;\n      var direction = goTo || itemsLength === 1 ? 'start' : 'end';\n\n      this._scrollTo(offset + (direction === 'start' ? -1 : 1), false);\n\n      clearTimeout(this._hackSlideAnimationTimeout);\n      this._hackSlideAnimationTimeout = setTimeout(function () {\n        _this4._scrollTo(offset, false);\n      }, 50);\n    }\n  }, {\n    key: \"_lockScroll\",\n    value: function _lockScroll() {\n      var _this5 = this;\n\n      var lockScrollTimeoutDuration = this.props.lockScrollTimeoutDuration;\n      clearTimeout(this._lockScrollTimeout);\n      this._lockScrollTimeout = setTimeout(function () {\n        _this5._releaseScroll();\n      }, lockScrollTimeoutDuration);\n\n      this._setScrollEnabled(false);\n    }\n  }, {\n    key: \"_releaseScroll\",\n    value: function _releaseScroll() {\n      clearTimeout(this._lockScrollTimeout);\n\n      this._setScrollEnabled(true);\n    }\n  }, {\n    key: \"_repositionScroll\",\n    value: function _repositionScroll(index) {\n      var _this$props12 = this.props,\n          data = _this$props12.data,\n          loopClonesPerSide = _this$props12.loopClonesPerSide;\n      var dataLength = data && data.length;\n\n      if (!this._enableLoop() || !dataLength || index >= loopClonesPerSide && index < dataLength + loopClonesPerSide) {\n        return;\n      }\n\n      var repositionTo = index;\n\n      if (index >= dataLength + loopClonesPerSide) {\n        repositionTo = index - dataLength;\n      } else if (index < loopClonesPerSide) {\n        repositionTo = index + dataLength;\n      }\n\n      this._snapToItem(repositionTo, false, false, false, false);\n    }\n  }, {\n    key: \"_scrollTo\",\n    value: function _scrollTo(offset) {\n      var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var vertical = this.props.vertical;\n\n      var wrappedRef = this._getWrappedRef();\n\n      if (!this._mounted || !wrappedRef) {\n        return;\n      }\n\n      var specificOptions = this._needsScrollView() ? {\n        x: vertical ? 0 : offset,\n        y: vertical ? offset : 0\n      } : {\n        offset: offset\n      };\n\n      var options = _objectSpread(_objectSpread({}, specificOptions), {}, {\n        animated: animated\n      });\n\n      if (this._needsScrollView()) {\n        wrappedRef.scrollTo(options);\n      } else {\n        wrappedRef.scrollToOffset(options);\n      }\n    }\n  }, {\n    key: \"_onScroll\",\n    value: function _onScroll(event) {\n      var _this$props13 = this.props,\n          callbackOffsetMargin = _this$props13.callbackOffsetMargin,\n          enableMomentum = _this$props13.enableMomentum,\n          onScroll = _this$props13.onScroll;\n      var scrollOffset = event ? this._getScrollOffset(event) : this._currentContentOffset;\n\n      var nextActiveItem = this._getActiveItem(scrollOffset);\n\n      var itemReached = nextActiveItem === this._itemToSnapTo;\n      var scrollConditions = scrollOffset >= this._scrollOffsetRef - callbackOffsetMargin && scrollOffset <= this._scrollOffsetRef + callbackOffsetMargin;\n      this._currentContentOffset = scrollOffset;\n      this._onScrollTriggered = true;\n      this._lastScrollDate = Date.now();\n\n      if (this._activeItem !== nextActiveItem && this._shouldUseCustomAnimation()) {\n        this._playCustomSlideAnimation(this._activeItem, nextActiveItem);\n      }\n\n      if (enableMomentum) {\n        clearTimeout(this._snapNoMomentumTimeout);\n\n        if (this._activeItem !== nextActiveItem) {\n          this._activeItem = nextActiveItem;\n        }\n\n        if (itemReached) {\n          if (this._canFireBeforeCallback) {\n            this._onBeforeSnap(this._getDataIndex(nextActiveItem));\n          }\n\n          if (scrollConditions && this._canFireCallback) {\n            this._onSnap(this._getDataIndex(nextActiveItem));\n          }\n        }\n      } else if (this._activeItem !== nextActiveItem && itemReached) {\n        if (this._canFireBeforeCallback) {\n          this._onBeforeSnap(this._getDataIndex(nextActiveItem));\n        }\n\n        if (scrollConditions) {\n          this._activeItem = nextActiveItem;\n\n          if (this._canLockScroll()) {\n            this._releaseScroll();\n          }\n\n          if (this._canFireCallback) {\n            this._onSnap(this._getDataIndex(nextActiveItem));\n          }\n        }\n      }\n\n      if (nextActiveItem === this._itemToSnapTo && scrollOffset === this._scrollOffsetRef) {\n        this._repositionScroll(nextActiveItem);\n      }\n\n      if (typeof onScroll === \"function\" && event) {\n        onScroll(event);\n      }\n    }\n  }, {\n    key: \"_onStartShouldSetResponderCapture\",\n    value: function _onStartShouldSetResponderCapture(event) {\n      var onStartShouldSetResponderCapture = this.props.onStartShouldSetResponderCapture;\n\n      if (onStartShouldSetResponderCapture) {\n        onStartShouldSetResponderCapture(event);\n      }\n\n      return this._getScrollEnabled();\n    }\n  }, {\n    key: \"_onTouchStart\",\n    value: function _onTouchStart() {\n      var onTouchStart = this.props.onTouchStart;\n\n      if (this._getScrollEnabled() !== false && this._autoplaying) {\n        this.pauseAutoPlay();\n      }\n\n      if (onTouchStart) {\n        onTouchStart();\n      }\n    }\n  }, {\n    key: \"_onTouchEnd\",\n    value: function _onTouchEnd() {\n      var onTouchEnd = this.props.onTouchEnd;\n\n      if (this._getScrollEnabled() !== false && this._autoplay && !this._autoplaying) {\n        this.startAutoplay();\n      }\n\n      if (onTouchEnd) {\n        onTouchEnd();\n      }\n    }\n  }, {\n    key: \"_onScrollBeginDrag\",\n    value: function _onScrollBeginDrag(event) {\n      var onScrollBeginDrag = this.props.onScrollBeginDrag;\n\n      if (!this._getScrollEnabled()) {\n        return;\n      }\n\n      this._scrollStartOffset = this._getScrollOffset(event);\n      this._scrollStartActive = this._getActiveItem(this._scrollStartOffset);\n      this._ignoreNextMomentum = false;\n\n      if (onScrollBeginDrag) {\n        onScrollBeginDrag(event);\n      }\n    }\n  }, {\n    key: \"_onScrollEndDrag\",\n    value: function _onScrollEndDrag(event) {\n      var onScrollEndDrag = this.props.onScrollEndDrag;\n\n      if (this._carouselRef) {\n        this._onScrollEnd && this._onScrollEnd();\n      }\n\n      if (onScrollEndDrag) {\n        onScrollEndDrag(event);\n      }\n    }\n  }, {\n    key: \"_onMomentumScrollEnd\",\n    value: function _onMomentumScrollEnd(event) {\n      var onMomentumScrollEnd = this.props.onMomentumScrollEnd;\n\n      if (this._carouselRef) {\n        this._onScrollEnd && this._onScrollEnd();\n      }\n\n      if (onMomentumScrollEnd) {\n        onMomentumScrollEnd(event);\n      }\n    }\n  }, {\n    key: \"_onScrollEnd\",\n    value: function _onScrollEnd(event) {\n      var _this6 = this;\n\n      var _this$props14 = this.props,\n          autoplayDelay = _this$props14.autoplayDelay,\n          enableSnap = _this$props14.enableSnap;\n\n      if (this._ignoreNextMomentum) {\n        this._ignoreNextMomentum = false;\n        return;\n      }\n\n      if (this._currentContentOffset === this._scrollEndOffset) {\n        return;\n      }\n\n      this._scrollEndOffset = this._currentContentOffset;\n      this._scrollEndActive = this._getActiveItem(this._scrollEndOffset);\n\n      if (enableSnap) {\n        this._snapScroll(this._scrollEndOffset - this._scrollStartOffset);\n      }\n\n      if (this._autoplay && !this._autoplaying) {\n        clearTimeout(this._enableAutoplayTimeout);\n        this._enableAutoplayTimeout = setTimeout(function () {\n          _this6.startAutoplay();\n        }, autoplayDelay + 50);\n      }\n    }\n  }, {\n    key: \"_onTouchRelease\",\n    value: function _onTouchRelease(event) {\n      var _this7 = this;\n\n      var enableMomentum = this.props.enableMomentum;\n\n      if (enableMomentum && IS_IOS) {\n        clearTimeout(this._snapNoMomentumTimeout);\n        this._snapNoMomentumTimeout = setTimeout(function () {\n          _this7._snapToItem(_this7._activeItem);\n        }, 100);\n      }\n    }\n  }, {\n    key: \"_onLayout\",\n    value: function _onLayout(event) {\n      var onLayout = this.props.onLayout;\n\n      if (this._onLayoutInitDone) {\n        this._initPositionsAndInterpolators();\n\n        this._snapToItem(this._activeItem, false, false, false, false);\n      } else {\n        this._onLayoutInitDone = true;\n      }\n\n      if (onLayout) {\n        onLayout(event);\n      }\n    }\n  }, {\n    key: \"_snapScroll\",\n    value: function _snapScroll(delta) {\n      var swipeThreshold = this.props.swipeThreshold;\n\n      if (!this._scrollEndActive && this._scrollEndActive !== 0 && IS_IOS) {\n        this._scrollEndActive = this._scrollStartActive;\n      }\n\n      if (this._scrollStartActive !== this._scrollEndActive) {\n        this._snapToItem(this._scrollEndActive);\n      } else {\n        if (delta > 0) {\n          if (delta > swipeThreshold) {\n            this._snapToItem(this._scrollStartActive + 1);\n          } else {\n            this._snapToItem(this._scrollEndActive);\n          }\n        } else if (delta < 0) {\n          if (delta < -swipeThreshold) {\n            this._snapToItem(this._scrollStartActive - 1);\n          } else {\n            this._snapToItem(this._scrollEndActive);\n          }\n        } else {\n          this._snapToItem(this._scrollEndActive);\n        }\n      }\n    }\n  }, {\n    key: \"_snapToItem\",\n    value: function _snapToItem(index) {\n      var _this8 = this;\n\n      var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var fireCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var initial = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var lockScroll = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n      var _this$props15 = this.props,\n          enableMomentum = _this$props15.enableMomentum,\n          onSnapToItem = _this$props15.onSnapToItem,\n          onBeforeSnapToItem = _this$props15.onBeforeSnapToItem;\n\n      var itemsLength = this._getCustomDataLength();\n\n      var wrappedRef = this._getWrappedRef();\n\n      if (!itemsLength || !wrappedRef) {\n        return;\n      }\n\n      if (!index || index < 0) {\n        index = 0;\n      } else if (itemsLength > 0 && index >= itemsLength) {\n        index = itemsLength - 1;\n      }\n\n      if (index !== this._previousActiveItem) {\n        this._previousActiveItem = index;\n\n        if (lockScroll && this._canLockScroll()) {\n          this._lockScroll();\n        }\n\n        if (fireCallback) {\n          if (onBeforeSnapToItem) {\n            this._canFireBeforeCallback = true;\n          }\n\n          if (onSnapToItem) {\n            this._canFireCallback = true;\n          }\n        }\n      }\n\n      this._itemToSnapTo = index;\n      this._scrollOffsetRef = this._positions[index] && this._positions[index].start;\n      this._onScrollTriggered = false;\n\n      if (!this._scrollOffsetRef && this._scrollOffsetRef !== 0) {\n        return;\n      }\n\n      this._scrollTo(this._scrollOffsetRef, animated);\n\n      this._scrollEndOffset = this._currentContentOffset;\n\n      if (enableMomentum) {\n        if (!initial) {\n          this._ignoreNextMomentum = true;\n        }\n\n        if (index === 0 || index === itemsLength - 1) {\n          clearTimeout(this._edgeItemTimeout);\n          this._edgeItemTimeout = setTimeout(function () {\n            if (!initial && index === _this8._activeItem && !_this8._onScrollTriggered) {\n              _this8._onScroll();\n            }\n          }, 250);\n        }\n      }\n    }\n  }, {\n    key: \"_onBeforeSnap\",\n    value: function _onBeforeSnap(index) {\n      var onBeforeSnapToItem = this.props.onBeforeSnapToItem;\n\n      if (!this._carouselRef) {\n        return;\n      }\n\n      this._canFireBeforeCallback = false;\n      onBeforeSnapToItem && onBeforeSnapToItem(index);\n    }\n  }, {\n    key: \"_onSnap\",\n    value: function _onSnap(index) {\n      var onSnapToItem = this.props.onSnapToItem;\n\n      if (!this._carouselRef) {\n        return;\n      }\n\n      this._canFireCallback = false;\n      onSnapToItem && onSnapToItem(index);\n    }\n  }, {\n    key: \"startAutoplay\",\n    value: function startAutoplay() {\n      var _this9 = this;\n\n      var _this$props16 = this.props,\n          autoplayInterval = _this$props16.autoplayInterval,\n          autoplayDelay = _this$props16.autoplayDelay;\n      this._autoplay = true;\n\n      if (this._autoplaying) {\n        return;\n      }\n\n      clearTimeout(this._autoplayTimeout);\n      this._autoplayTimeout = setTimeout(function () {\n        _this9._autoplaying = true;\n        _this9._autoplayInterval = setInterval(function () {\n          if (_this9._autoplaying) {\n            _this9.snapToNext();\n          }\n        }, autoplayInterval);\n      }, autoplayDelay);\n    }\n  }, {\n    key: \"pauseAutoPlay\",\n    value: function pauseAutoPlay() {\n      this._autoplaying = false;\n      clearTimeout(this._autoplayTimeout);\n      clearTimeout(this._enableAutoplayTimeout);\n      clearInterval(this._autoplayInterval);\n    }\n  }, {\n    key: \"stopAutoplay\",\n    value: function stopAutoplay() {\n      this._autoplay = false;\n      this.pauseAutoPlay();\n    }\n  }, {\n    key: \"snapToItem\",\n    value: function snapToItem(index) {\n      var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var fireCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n      if (!index || index < 0) {\n        index = 0;\n      }\n\n      var positionIndex = this._getPositionIndex(index);\n\n      if (positionIndex === this._activeItem) {\n        return;\n      }\n\n      this._snapToItem(positionIndex, animated, fireCallback);\n    }\n  }, {\n    key: \"snapToNext\",\n    value: function snapToNext() {\n      var animated = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var fireCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      var itemsLength = this._getCustomDataLength();\n\n      var newIndex = this._activeItem + 1;\n\n      if (newIndex > itemsLength - 1) {\n        if (!this._enableLoop()) {\n          return;\n        }\n\n        newIndex = 0;\n      }\n\n      this._snapToItem(newIndex, animated, fireCallback);\n    }\n  }, {\n    key: \"snapToPrev\",\n    value: function snapToPrev() {\n      var animated = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var fireCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      var itemsLength = this._getCustomDataLength();\n\n      var newIndex = this._activeItem - 1;\n\n      if (newIndex < 0) {\n        if (!this._enableLoop()) {\n          return;\n        }\n\n        newIndex = itemsLength - 1;\n      }\n\n      this._snapToItem(newIndex, animated, fireCallback);\n    }\n  }, {\n    key: \"triggerRenderingHack\",\n    value: function triggerRenderingHack(offset) {\n      if (Date.now() - this._lastScrollDate < 500) {\n        return;\n      }\n\n      var scrollPosition = this._currentContentOffset;\n\n      if (!scrollPosition && scrollPosition !== 0) {\n        return;\n      }\n\n      var scrollOffset = offset || (scrollPosition === 0 ? 1 : -1);\n\n      this._scrollTo(scrollPosition + scrollOffset, false);\n    }\n  }, {\n    key: \"_getSlideInterpolatedStyle\",\n    value: function _getSlideInterpolatedStyle(index, animatedValue) {\n      var _this$props17 = this.props,\n          layoutCardOffset = _this$props17.layoutCardOffset,\n          slideInterpolatedStyle = _this$props17.slideInterpolatedStyle;\n\n      if (slideInterpolatedStyle) {\n        return slideInterpolatedStyle(index, animatedValue, this.props);\n      } else if (this._shouldUseTinderLayout()) {\n        return tinderAnimatedStyles(index, animatedValue, this.props, layoutCardOffset);\n      } else if (this._shouldUseStackLayout()) {\n        return stackAnimatedStyles(index, animatedValue, this.props, layoutCardOffset);\n      } else if (this._shouldUseShiftLayout()) {\n        return shiftAnimatedStyles(index, animatedValue, this.props);\n      } else {\n        return defaultAnimatedStyles(index, animatedValue, this.props);\n      }\n    }\n  }, {\n    key: \"_renderItem\",\n    value: function _renderItem(_ref) {\n      var item = _ref.item,\n          index = _ref.index;\n      var interpolators = this.state.interpolators;\n      var _this$props18 = this.props,\n          hasParallaxImages = _this$props18.hasParallaxImages,\n          itemWidth = _this$props18.itemWidth,\n          itemHeight = _this$props18.itemHeight,\n          keyExtractor = _this$props18.keyExtractor,\n          renderItem = _this$props18.renderItem,\n          sliderHeight = _this$props18.sliderHeight,\n          sliderWidth = _this$props18.sliderWidth,\n          slideStyle = _this$props18.slideStyle,\n          vertical = _this$props18.vertical;\n      var animatedValue = interpolators && interpolators[index];\n\n      if (!animatedValue && animatedValue !== 0) {\n        return null;\n      }\n\n      var animate = this._shouldAnimateSlides();\n\n      var Component = animate ? Animated.View : View;\n      var animatedStyle = animate ? this._getSlideInterpolatedStyle(index, animatedValue) : {};\n      var parallaxProps = hasParallaxImages ? {\n        scrollPosition: this._scrollPos,\n        carouselRef: this._carouselRef,\n        vertical: vertical,\n        sliderWidth: sliderWidth,\n        sliderHeight: sliderHeight,\n        itemWidth: itemWidth,\n        itemHeight: itemHeight\n      } : undefined;\n      var mainDimension = vertical ? {\n        height: itemHeight\n      } : {\n        width: itemWidth\n      };\n      var specificProps = this._needsScrollView() ? {\n        key: keyExtractor ? keyExtractor(item, index) : this._getKeyExtractor(item, index)\n      } : {};\n      return React.createElement(Component, _extends({\n        style: [mainDimension, slideStyle, animatedStyle],\n        pointerEvents: 'box-none'\n      }, specificProps, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 1237,\n          columnNumber: 13\n        }\n      }), renderItem({\n        item: item,\n        index: index\n      }, parallaxProps));\n    }\n  }, {\n    key: \"_getComponentOverridableProps\",\n    value: function _getComponentOverridableProps() {\n      var _this$props19 = this.props,\n          enableMomentum = _this$props19.enableMomentum,\n          itemWidth = _this$props19.itemWidth,\n          itemHeight = _this$props19.itemHeight,\n          loopClonesPerSide = _this$props19.loopClonesPerSide,\n          sliderWidth = _this$props19.sliderWidth,\n          sliderHeight = _this$props19.sliderHeight,\n          vertical = _this$props19.vertical;\n      var visibleItems = Math.ceil(vertical ? sliderHeight / itemHeight : sliderWidth / itemWidth) + 1;\n      var initialNumPerSide = this._enableLoop() ? loopClonesPerSide : 2;\n      var initialNumToRender = visibleItems + initialNumPerSide * 2;\n      var maxToRenderPerBatch = 1 + initialNumToRender * 2;\n      var windowSize = maxToRenderPerBatch;\n      var specificProps = !this._needsScrollView() ? {\n        initialNumToRender: initialNumToRender,\n        maxToRenderPerBatch: maxToRenderPerBatch,\n        windowSize: windowSize\n      } : {};\n      return _objectSpread({\n        decelerationRate: enableMomentum ? 0.9 : 'fast',\n        showsHorizontalScrollIndicator: false,\n        showsVerticalScrollIndicator: false,\n        overScrollMode: 'never',\n        automaticallyAdjustContentInsets: false,\n        directionalLockEnabled: true,\n        pinchGestureEnabled: false,\n        scrollsToTop: false,\n        removeClippedSubviews: !this._needsScrollView(),\n        inverted: this._needsRTLAdaptations()\n      }, specificProps);\n    }\n  }, {\n    key: \"_getComponentStaticProps\",\n    value: function _getComponentStaticProps() {\n      var _this10 = this;\n\n      var hideCarousel = this.state.hideCarousel;\n      var _this$props20 = this.props,\n          containerCustomStyle = _this$props20.containerCustomStyle,\n          contentContainerCustomStyle = _this$props20.contentContainerCustomStyle,\n          keyExtractor = _this$props20.keyExtractor,\n          sliderWidth = _this$props20.sliderWidth,\n          sliderHeight = _this$props20.sliderHeight,\n          style = _this$props20.style,\n          vertical = _this$props20.vertical;\n      var containerStyle = [containerCustomStyle || style || {}, hideCarousel ? {\n        opacity: 0\n      } : {}, vertical ? {\n        height: sliderHeight,\n        flexDirection: 'column'\n      } : {\n        width: sliderWidth,\n        flexDirection: this._needsRTLAdaptations() ? 'row-reverse' : 'row'\n      }];\n      var contentContainerStyle = [vertical ? {\n        paddingTop: this._getContainerInnerMargin(),\n        paddingBottom: this._getContainerInnerMargin(true)\n      } : {\n        paddingLeft: this._getContainerInnerMargin(),\n        paddingRight: this._getContainerInnerMargin(true)\n      }, contentContainerCustomStyle || {}];\n      var specificProps = !this._needsScrollView() ? {\n        renderItem: this._renderItem,\n        numColumns: 1,\n        keyExtractor: keyExtractor || this._getKeyExtractor\n      } : {};\n      return _objectSpread({\n        ref: function ref(c) {\n          return _this10._carouselRef = c;\n        },\n        data: this._getCustomData(),\n        style: containerStyle,\n        contentContainerStyle: contentContainerStyle,\n        horizontal: !vertical,\n        scrollEventThrottle: 1,\n        onScroll: this._onScrollHandler,\n        onScrollBeginDrag: this._onScrollBeginDrag,\n        onScrollEndDrag: this._onScrollEndDrag,\n        onMomentumScrollEnd: this._onMomentumScrollEnd,\n        onResponderRelease: this._onTouchRelease,\n        onStartShouldSetResponderCapture: this._onStartShouldSetResponderCapture,\n        onTouchStart: this._onTouchStart,\n        onTouchEnd: this._onScrollEnd,\n        onLayout: this._onLayout\n      }, specificProps);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this11 = this;\n\n      var _this$props21 = this.props,\n          data = _this$props21.data,\n          renderItem = _this$props21.renderItem,\n          useScrollView = _this$props21.useScrollView;\n\n      if (!data || !renderItem) {\n        return null;\n      }\n\n      var props = _objectSpread(_objectSpread(_objectSpread({}, this._getComponentOverridableProps()), this.props), this._getComponentStaticProps());\n\n      var ScrollViewComponent = typeof useScrollView === 'function' ? useScrollView : AnimatedScrollView;\n      return this._needsScrollView() ? React.createElement(ScrollViewComponent, _extends({}, props, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 1360,\n          columnNumber: 13\n        }\n      }), this._getCustomData().map(function (item, index) {\n        return _this11._renderItem({\n          item: item,\n          index: index\n        });\n      })) : React.createElement(AnimatedFlatList, _extends({}, props, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 1368,\n          columnNumber: 13\n        }\n      }));\n    }\n  }]);\n\n  return Carousel;\n}(Component);\n\nCarousel.propTypes = {\n  data: PropTypes.array.isRequired,\n  renderItem: PropTypes.func.isRequired,\n  itemWidth: PropTypes.number,\n  itemHeight: PropTypes.number,\n  sliderWidth: PropTypes.number,\n  sliderHeight: PropTypes.number,\n  activeAnimationType: PropTypes.string,\n  activeAnimationOptions: PropTypes.object,\n  activeSlideAlignment: PropTypes.oneOf(['center', 'end', 'start']),\n  activeSlideOffset: PropTypes.number,\n  apparitionDelay: PropTypes.number,\n  autoplay: PropTypes.bool,\n  autoplayDelay: PropTypes.number,\n  autoplayInterval: PropTypes.number,\n  callbackOffsetMargin: PropTypes.number,\n  containerCustomStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n  contentContainerCustomStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n  enableMomentum: PropTypes.bool,\n  enableSnap: PropTypes.bool,\n  firstItem: PropTypes.number,\n  hasParallaxImages: PropTypes.bool,\n  inactiveSlideOpacity: PropTypes.number,\n  inactiveSlideScale: PropTypes.number,\n  inactiveSlideShift: PropTypes.number,\n  layout: PropTypes.oneOf(['default', 'stack', 'tinder']),\n  layoutCardOffset: PropTypes.number,\n  lockScrollTimeoutDuration: PropTypes.number,\n  lockScrollWhileSnapping: PropTypes.bool,\n  loop: PropTypes.bool,\n  loopClonesPerSide: PropTypes.number,\n  scrollEnabled: PropTypes.bool,\n  scrollInterpolator: PropTypes.func,\n  slideInterpolatedStyle: PropTypes.func,\n  slideStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n  shouldOptimizeUpdates: PropTypes.bool,\n  swipeThreshold: PropTypes.number,\n  useScrollView: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n  vertical: PropTypes.bool,\n  onBeforeSnapToItem: PropTypes.func,\n  onSnapToItem: PropTypes.func\n};\nCarousel.defaultProps = {\n  activeAnimationType: 'timing',\n  activeAnimationOptions: null,\n  activeSlideAlignment: 'center',\n  activeSlideOffset: 20,\n  apparitionDelay: 0,\n  autoplay: false,\n  autoplayDelay: 1000,\n  autoplayInterval: 3000,\n  callbackOffsetMargin: 5,\n  containerCustomStyle: {},\n  contentContainerCustomStyle: {},\n  enableMomentum: false,\n  enableSnap: true,\n  firstItem: 0,\n  hasParallaxImages: false,\n  inactiveSlideOpacity: 0.7,\n  inactiveSlideScale: 0.9,\n  inactiveSlideShift: 0,\n  layout: 'default',\n  lockScrollTimeoutDuration: 1000,\n  lockScrollWhileSnapping: false,\n  loop: false,\n  loopClonesPerSide: 3,\n  scrollEnabled: true,\n  slideStyle: {},\n  shouldOptimizeUpdates: true,\n  swipeThreshold: 20,\n  useScrollView: !AnimatedFlatList,\n  vertical: false\n};\nexport { Carousel as default };","map":{"version":3,"sources":["E:/Users/Nayla/Escritorio/UADEE/Distribuidas desk/SUBASTAPP/node_modules/react-native-snap-carousel/src/carousel/Carousel.js"],"names":["React","Component","ViewPropTypes","PropTypes","shallowCompare","defaultScrollInterpolator","stackScrollInterpolator","tinderScrollInterpolator","defaultAnimatedStyles","shiftAnimatedStyles","stackAnimatedStyles","tinderAnimatedStyles","IS_IOS","Platform","OS","AnimatedFlatList","FlatList","Animated","createAnimatedComponent","AnimatedScrollView","ScrollView","IS_RTL","I18nManager","isRTL","Carousel","props","state","hideCarousel","interpolators","initialActiveItem","_getFirstItem","firstItem","_activeItem","_previousActiveItem","_previousFirstItem","_previousItemsLength","_mounted","_positions","_currentContentOffset","_canFireBeforeCallback","_canFireCallback","_scrollOffsetRef","_onScrollTriggered","_lastScrollDate","_scrollEnabled","scrollEnabled","_initPositionsAndInterpolators","bind","_renderItem","_onSnap","_onLayout","_onScroll","_onScrollBeginDrag","enableSnap","undefined","_onScrollEnd","autoplay","_onScrollEndDrag","enableMomentum","_onMomentumScrollEnd","_onTouchStart","_onTouchEnd","_onTouchRelease","_getKeyExtractor","_setScrollHandler","_ignoreNextMomentum","console","warn","vertical","sliderWidth","itemWidth","error","sliderHeight","itemHeight","apparitionDelay","useScrollView","customAnimationType","customAnimationOptions","onScrollViewScroll","_firstItem","apparitionCallback","setState","startAutoplay","requestAnimationFrame","_snapToItem","_hackActiveSlideAnimation","_apparitionTimeout","setTimeout","nextProps","nextState","shouldOptimizeUpdates","prevProps","itemsLength","_getCustomDataLength","nextFirstItem","nextActiveItem","hasNewSliderWidth","hasNewSliderHeight","hasNewItemWidth","hasNewItemHeight","hasNewScrollEnabled","_setScrollEnabled","length","onScroll","stopAutoplay","clearTimeout","_hackSlideAnimationTimeout","_enableAutoplayTimeout","_autoplayTimeout","_snapNoMomentumTimeout","_edgeItemTimeout","_lockScrollTimeout","_getDataIndex","scrollEventConfig","listener","useNativeDriver","_scrollPos","Value","argMapping","nativeEvent","contentOffset","y","x","Array","isArray","_argMapping","pop","argMap","push","_onScrollHandler","event","_shouldUseStackLayout","_shouldUseTinderLayout","lockScrollWhileSnapping","data","loop","inactiveSlideOpacity","inactiveSlideScale","scrollInterpolator","slideInterpolatedStyle","_shouldUseShiftLayout","activeAnimationOptions","inactiveSlideShift","layout","loopClonesPerSide","dataLength","_enableLoop","previousItems","nextItems","dataMultiplier","Math","floor","remainder","i","unshift","slice","concat","index","_needsRTLAdaptations","baseDataIndexes","dataIndexes","j","_carouselRef","_needsScrollView","scrollTo","scrollToOffset","getNode","wrappedRef","_getWrappedRef","setNativeProps","item","opposite","activeSlideAlignment","offset","_getViewportOffset","_getContainerInnerMargin","activeSlideOffset","swipeThreshold","center","_getCenter","centerOffset","start","end","lastIndex","sizeRef","_getCustomData","forEach","itemData","_index","_getCustomIndex","animatedValue","_shouldAnimateSlides","_shouldUseCustomAnimation","interpolator","inputRange","outputRange","interpolate","extrapolate","toValue","activeAnimationType","animationCommonOptions","isInteraction","parallel","easing","Easing","linear","current","next","_currentIndex","_currentDataIndex","_nextIndex","_nextDataIndex","animations","_getSlideAnimation","stopTogether","goTo","force","direction","_scrollTo","lockScrollTimeoutDuration","_releaseScroll","repositionTo","animated","specificOptions","options","callbackOffsetMargin","scrollOffset","_getScrollOffset","_getActiveItem","itemReached","_itemToSnapTo","scrollConditions","Date","now","_playCustomSlideAnimation","_onBeforeSnap","_canLockScroll","_repositionScroll","onStartShouldSetResponderCapture","_getScrollEnabled","onTouchStart","_autoplaying","pauseAutoPlay","onTouchEnd","_autoplay","onScrollBeginDrag","_scrollStartOffset","_scrollStartActive","onScrollEndDrag","onMomentumScrollEnd","autoplayDelay","_scrollEndOffset","_scrollEndActive","_snapScroll","onLayout","_onLayoutInitDone","delta","fireCallback","initial","lockScroll","onSnapToItem","onBeforeSnapToItem","_lockScroll","autoplayInterval","_autoplayInterval","setInterval","snapToNext","clearInterval","positionIndex","_getPositionIndex","newIndex","scrollPosition","layoutCardOffset","hasParallaxImages","keyExtractor","renderItem","slideStyle","animate","View","animatedStyle","_getSlideInterpolatedStyle","parallaxProps","carouselRef","mainDimension","height","width","specificProps","key","visibleItems","ceil","initialNumPerSide","initialNumToRender","maxToRenderPerBatch","windowSize","decelerationRate","showsHorizontalScrollIndicator","showsVerticalScrollIndicator","overScrollMode","automaticallyAdjustContentInsets","directionalLockEnabled","pinchGestureEnabled","scrollsToTop","removeClippedSubviews","inverted","containerCustomStyle","contentContainerCustomStyle","style","containerStyle","opacity","flexDirection","contentContainerStyle","paddingTop","paddingBottom","paddingLeft","paddingRight","numColumns","ref","c","horizontal","scrollEventThrottle","onResponderRelease","_onStartShouldSetResponderCapture","_getComponentOverridableProps","_getComponentStaticProps","ScrollViewComponent","map","propTypes","array","isRequired","func","number","string","object","oneOf","bool","oneOfType","defaultProps"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;;;;;;;;SAC8EC,a;AAC9E,OAAOC,SAAP,MAAsB,YAAtB;AACA,OAAOC,cAAP,MAA2B,8BAA3B;AACA,SACIC,yBADJ,EAEIC,uBAFJ,EAGIC,wBAHJ,EAIIC,qBAJJ,EAKIC,mBALJ,EAMIC,mBANJ,EAOIC,oBAPJ;AAUA,IAAMC,MAAM,GAAGC,QAAQ,CAACC,EAAT,KAAgB,KAA/B;AAIA,IAAMC,gBAAgB,GAAGC,QAAQ,GAAGC,QAAQ,CAACC,uBAAT,CAAiCF,QAAjC,CAAH,GAAgD,IAAjF;AACA,IAAMG,kBAAkB,GAAGF,QAAQ,CAACC,uBAAT,CAAiCE,UAAjC,CAA3B;AAMA,IAAMC,MAAM,GAAGC,WAAW,CAACC,KAA3B;;IAEqBC,Q;;;;;AA6EjB,oBAAaC,KAAb,EAAoB;AAAA;;AAAA;;AAChB,8BAAMA,KAAN;AAEA,UAAKC,KAAL,GAAa;AACTC,MAAAA,YAAY,EAAE,IADL;AAETC,MAAAA,aAAa,EAAE;AAFN,KAAb;;AAOA,QAAMC,iBAAiB,GAAG,MAAKC,aAAL,CAAmBL,KAAK,CAACM,SAAzB,CAA1B;;AACA,UAAKC,WAAL,GAAmBH,iBAAnB;AACA,UAAKI,mBAAL,GAA2BJ,iBAA3B;AACA,UAAKK,kBAAL,GAA0BL,iBAA1B;AACA,UAAKM,oBAAL,GAA4BN,iBAA5B;AAEA,UAAKO,QAAL,GAAgB,KAAhB;AACA,UAAKC,UAAL,GAAkB,EAAlB;AACA,UAAKC,qBAAL,GAA6B,CAA7B;AACA,UAAKC,sBAAL,GAA8B,KAA9B;AACA,UAAKC,gBAAL,GAAwB,KAAxB;AACA,UAAKC,gBAAL,GAAwB,IAAxB;AACA,UAAKC,kBAAL,GAA0B,IAA1B;AACA,UAAKC,eAAL,GAAuB,CAAvB;AACA,UAAKC,cAAL,GAAsBnB,KAAK,CAACoB,aAAN,KAAwB,KAA9C;AAEA,UAAKC,8BAAL,GAAsC,MAAKA,8BAAL,CAAoCC,IAApC,+BAAtC;AACA,UAAKC,WAAL,GAAmB,MAAKA,WAAL,CAAiBD,IAAjB,+BAAnB;AACA,UAAKE,OAAL,GAAe,MAAKA,OAAL,CAAaF,IAAb,+BAAf;AAEA,UAAKG,SAAL,GAAiB,MAAKA,SAAL,CAAeH,IAAf,+BAAjB;AACA,UAAKI,SAAL,GAAiB,MAAKA,SAAL,CAAeJ,IAAf,+BAAjB;AACA,UAAKK,kBAAL,GAA0B3B,KAAK,CAAC4B,UAAN,GAAmB,MAAKD,kBAAL,CAAwBL,IAAxB,+BAAnB,GAAwDO,SAAlF;AACA,UAAKC,YAAL,GAAoB9B,KAAK,CAAC4B,UAAN,IAAoB5B,KAAK,CAAC+B,QAA1B,GAAqC,MAAKD,YAAL,CAAkBR,IAAlB,+BAArC,GAAoEO,SAAxF;AACA,UAAKG,gBAAL,GAAwB,CAAChC,KAAK,CAACiC,cAAP,GAAwB,MAAKD,gBAAL,CAAsBV,IAAtB,+BAAxB,GAA2DO,SAAnF;AACA,UAAKK,oBAAL,GAA4BlC,KAAK,CAACiC,cAAN,GAAuB,MAAKC,oBAAL,CAA0BZ,IAA1B,+BAAvB,GAA8DO,SAA1F;AACA,UAAKM,aAAL,GAAqB,MAAKA,aAAL,CAAmBb,IAAnB,+BAArB;AACA,UAAKc,WAAL,GAAmB,MAAKA,WAAL,CAAiBd,IAAjB,+BAAnB;AACA,UAAKe,eAAL,GAAuB,MAAKA,eAAL,CAAqBf,IAArB,+BAAvB;AAEA,UAAKgB,gBAAL,GAAwB,MAAKA,gBAAL,CAAsBhB,IAAtB,+BAAxB;;AAEA,UAAKiB,iBAAL,CAAuBvC,KAAvB;;AAIA,UAAKwC,mBAAL,GAA2B,KAA3B;;AAGA,QAAI,CAAC/D,aAAL,EAAoB;AAChBgE,MAAAA,OAAO,CAACC,IAAR,CAAa,4GAAb;AACH;;AACD,QAAI,CAAC1C,KAAK,CAAC2C,QAAP,KAAoB,CAAC3C,KAAK,CAAC4C,WAAP,IAAsB,CAAC5C,KAAK,CAAC6C,SAAjD,CAAJ,EAAiE;AAC7DJ,MAAAA,OAAO,CAACK,KAAR,CAAc,6GAAd;AACH;;AACD,QAAI9C,KAAK,CAAC2C,QAAN,KAAmB,CAAC3C,KAAK,CAAC+C,YAAP,IAAuB,CAAC/C,KAAK,CAACgD,UAAjD,CAAJ,EAAkE;AAC9DP,MAAAA,OAAO,CAACK,KAAR,CAAc,6GAAd;AACH;;AACD,QAAI9C,KAAK,CAACiD,eAAN,IAAyB,CAAC9D,MAA1B,IAAoC,CAACa,KAAK,CAACkD,aAA/C,EAA8D;AAC1DT,MAAAA,OAAO,CAACC,IAAR,CAAa,yHAAb;AACH;;AACD,QAAI1C,KAAK,CAACmD,mBAAN,IAA6BnD,KAAK,CAACoD,sBAAvC,EAA+D;AAC3DX,MAAAA,OAAO,CAACC,IAAR,CAAa,8JAAb;AACH;;AACD,QAAI1C,KAAK,CAACqD,kBAAV,EAA8B;AAC1BZ,MAAAA,OAAO,CAACK,KAAR,CAAc,gGAAd;AACH;;AAlEe;AAmEnB;;;;WAED,6BAAqB;AAAA;;AAAA,wBACgC,KAAK9C,KADrC;AAAA,UACTiD,eADS,eACTA,eADS;AAAA,UACQlB,QADR,eACQA,QADR;AAAA,UACkBzB,SADlB,eACkBA,SADlB;;AAEjB,UAAMgD,UAAU,GAAG,KAAKjD,aAAL,CAAmBC,SAAnB,CAAnB;;AACA,UAAMiD,kBAAkB,GAAG,SAArBA,kBAAqB,GAAM;AAC7B,QAAA,MAAI,CAACC,QAAL,CAAc;AAAEtD,UAAAA,YAAY,EAAE;AAAhB,SAAd;;AACA,YAAI6B,QAAJ,EAAc;AACV,UAAA,MAAI,CAAC0B,aAAL;AACH;AACJ,OALD;;AAOA,WAAK9C,QAAL,GAAgB,IAAhB;;AACA,WAAKU,8BAAL;;AAGAqC,MAAAA,qBAAqB,CAAC,YAAM;AACxB,YAAI,CAAC,MAAI,CAAC/C,QAAV,EAAoB;AAChB;AACH;;AAED,QAAA,MAAI,CAACgD,WAAL,CAAiBL,UAAjB,EAA6B,KAA7B,EAAoC,KAApC,EAA2C,IAA3C,EAAiD,KAAjD;;AACA,QAAA,MAAI,CAACM,yBAAL,CAA+BN,UAA/B,EAA2C,OAA3C,EAAoD,IAApD;;AAEA,YAAIL,eAAJ,EAAqB;AACjB,UAAA,MAAI,CAACY,kBAAL,GAA0BC,UAAU,CAAC,YAAM;AACvCP,YAAAA,kBAAkB;AACrB,WAFmC,EAEjCN,eAFiC,CAApC;AAGH,SAJD,MAIO;AACHM,UAAAA,kBAAkB;AACrB;AACJ,OAfoB,CAArB;AAgBH;;;WAED,+BAAuBQ,SAAvB,EAAkCC,SAAlC,EAA6C;AACzC,UAAI,KAAKhE,KAAL,CAAWiE,qBAAX,KAAqC,KAAzC,EAAgD;AAC5C,eAAO,IAAP;AACH,OAFD,MAEO;AACH,eAAOtF,cAAc,CAAC,IAAD,EAAOoF,SAAP,EAAkBC,SAAlB,CAArB;AACH;AACJ;;;WAED,4BAAoBE,SAApB,EAA+B;AAAA,UACnB/D,aADmB,GACD,KAAKF,KADJ,CACnBE,aADmB;AAAA,yBAE4D,KAAKH,KAFjE;AAAA,UAEnBM,SAFmB,gBAEnBA,SAFmB;AAAA,UAER0C,UAFQ,gBAERA,UAFQ;AAAA,UAEIH,SAFJ,gBAEIA,SAFJ;AAAA,UAEezB,aAFf,gBAEeA,aAFf;AAAA,UAE8B2B,YAF9B,gBAE8BA,YAF9B;AAAA,UAE4CH,WAF5C,gBAE4CA,WAF5C;;AAG3B,UAAMuB,WAAW,GAAG,KAAKC,oBAAL,CAA0B,KAAKpE,KAA/B,CAApB;;AAEA,UAAI,CAACmE,WAAL,EAAkB;AACd;AACH;;AAED,UAAME,aAAa,GAAG,KAAKhE,aAAL,CAAmBC,SAAnB,EAA8B,KAAKN,KAAnC,CAAtB;;AACA,UAAIsE,cAAc,GAAG,KAAK/D,WAAL,IAAoB,KAAKA,WAAL,KAAqB,CAAzC,GAA6C,KAAKA,WAAlD,GAAgE8D,aAArF;AAEA,UAAME,iBAAiB,GAAG3B,WAAW,IAAIA,WAAW,KAAKsB,SAAS,CAACtB,WAAnE;AACA,UAAM4B,kBAAkB,GAAGzB,YAAY,IAAIA,YAAY,KAAKmB,SAAS,CAACnB,YAAtE;AACA,UAAM0B,eAAe,GAAG5B,SAAS,IAAIA,SAAS,KAAKqB,SAAS,CAACrB,SAA7D;AACA,UAAM6B,gBAAgB,GAAG1B,UAAU,IAAIA,UAAU,KAAKkB,SAAS,CAAClB,UAAhE;AACA,UAAM2B,mBAAmB,GAAGvD,aAAa,KAAK8C,SAAS,CAAC9C,aAAxD;;AAGA,UAAIkD,cAAc,GAAGH,WAAW,GAAG,CAAnC,EAAsC;AAClCG,QAAAA,cAAc,GAAGH,WAAW,GAAG,CAA/B;AACH;;AAGD,UAAIQ,mBAAJ,EAAyB;AACrB,aAAKC,iBAAL,CAAuBxD,aAAvB;AACH;;AAED,UAAIjB,aAAa,CAAC0E,MAAd,KAAyBV,WAAzB,IAAwCI,iBAAxC,IACAC,kBADA,IACsBC,eADtB,IACyCC,gBAD7C,EAC+D;AAC3D,aAAKnE,WAAL,GAAmB+D,cAAnB;AACA,aAAK5D,oBAAL,GAA4ByD,WAA5B;;AAEA,aAAK9C,8BAAL,CAAoC,KAAKrB,KAAzC;;AAKA,YAAI,KAAKU,oBAAL,GAA4ByD,WAAhC,EAA6C;AACzC,eAAKP,yBAAL,CAA+BU,cAA/B,EAA+C,IAA/C,EAAqD,IAArD;AACH;;AAED,YAAIC,iBAAiB,IAAIC,kBAArB,IAA2CC,eAA3C,IAA8DC,gBAAlE,EAAoF;AAChF,eAAKf,WAAL,CAAiBW,cAAjB,EAAiC,KAAjC,EAAwC,KAAxC,EAA+C,KAA/C,EAAsD,KAAtD;AACH;AACJ,OAjBD,MAiBO,IAAID,aAAa,KAAK,KAAK5D,kBAAvB,IAA6C4D,aAAa,KAAK,KAAK9D,WAAxE,EAAqF;AACxF,aAAKA,WAAL,GAAmB8D,aAAnB;AACA,aAAK5D,kBAAL,GAA0B4D,aAA1B;;AACA,aAAKV,WAAL,CAAiBU,aAAjB,EAAgC,KAAhC,EAAuC,IAAvC,EAA6C,KAA7C,EAAoD,KAApD;AACH;;AAED,UAAI,KAAKrE,KAAL,CAAW8E,QAAX,KAAwBZ,SAAS,CAACY,QAAtC,EAAgD;AAC9C,aAAKvC,iBAAL,CAAuB,KAAKvC,KAA5B;AACD;AACJ;;;WAED,gCAAwB;AACpB,WAAKW,QAAL,GAAgB,KAAhB;AACA,WAAKoE,YAAL;AACAC,MAAAA,YAAY,CAAC,KAAKnB,kBAAN,CAAZ;AACAmB,MAAAA,YAAY,CAAC,KAAKC,0BAAN,CAAZ;AACAD,MAAAA,YAAY,CAAC,KAAKE,sBAAN,CAAZ;AACAF,MAAAA,YAAY,CAAC,KAAKG,gBAAN,CAAZ;AACAH,MAAAA,YAAY,CAAC,KAAKI,sBAAN,CAAZ;AACAJ,MAAAA,YAAY,CAAC,KAAKK,gBAAN,CAAZ;AACAL,MAAAA,YAAY,CAAC,KAAKM,kBAAN,CAAZ;AACH;;;SAED,eAAiB;AACb,aAAO,KAAK/E,WAAZ;AACH;;;SAED,eAAoB;AAChB,aAAO,KAAKgF,aAAL,CAAmB,KAAKhF,WAAxB,CAAP;AACH;;;SAED,eAA6B;AACzB,aAAO,KAAKM,qBAAZ;AACH;;;WAED,2BAAkBb,KAAlB,EAAyB;AAEvB,UAAMwF,iBAAiB,GAAG;AACxBC,QAAAA,QAAQ,EAAE,KAAK/D,SADS;AAExBgE,QAAAA,eAAe,EAAE;AAFO,OAA1B;AAIA,WAAKC,UAAL,GAAkB,IAAInG,QAAQ,CAACoG,KAAb,CAAmB,CAAnB,CAAlB;AACA,UAAMC,UAAU,GAAG7F,KAAK,CAAC2C,QAAN,GACf,CAAC;AAAEmD,QAAAA,WAAW,EAAE;AAAEC,UAAAA,aAAa,EAAE;AAAEC,YAAAA,CAAC,EAAE,KAAKL;AAAV;AAAjB;AAAf,OAAD,CADe,GAEf,CAAC;AAAEG,QAAAA,WAAW,EAAE;AAAEC,UAAAA,aAAa,EAAE;AAAEE,YAAAA,CAAC,EAAE,KAAKN;AAAV;AAAjB;AAAf,OAAD,CAFJ;;AAIA,UAAI3F,KAAK,CAAC8E,QAAN,IAAkBoB,KAAK,CAACC,OAAN,CAAcnG,KAAK,CAAC8E,QAAN,CAAesB,WAA7B,CAAtB,EAAiE;AAE/DP,QAAAA,UAAU,CAACQ,GAAX;;AAF+D,mDAG5CrG,KAAK,CAAC8E,QAAN,CAAesB,WAH6B;AAAA,YAGvDE,MAHuD;;AAI/D,YAAIA,MAAM,IAAIA,MAAM,CAACR,WAAjB,IAAgCQ,MAAM,CAACR,WAAP,CAAmBC,aAAvD,EAAsE;AAEpE,eAAKJ,UAAL,GACEW,MAAM,CAACR,WAAP,CAAmBC,aAAnB,CAAiCE,CAAjC,IACAK,MAAM,CAACR,WAAP,CAAmBC,aAAnB,CAAiCC,CADjC,IAEA,KAAKL,UAHP;AAID;;AACDE,QAAAA,UAAU,CAACU,IAAX,OAAAV,UAAU,qBAAS7F,KAAK,CAAC8E,QAAN,CAAesB,WAAxB,EAAV;AACD;;AACD,WAAKI,gBAAL,GAAwBhH,QAAQ,CAACiH,KAAT,CACtBZ,UADsB,EAEtBL,iBAFsB,CAAxB;AAID;;;WAED,4BAAoB;AAAA,UACRtC,aADQ,GACU,KAAKlD,KADf,CACRkD,aADQ;AAEhB,aAAOA,aAAa,IAAI,CAAC5D,gBAAlB,IAAsC,KAAKoH,qBAAL,EAAtC,IAAsE,KAAKC,sBAAL,EAA7E;AACH;;;WAED,gCAAwB;AAAA,UACZhE,QADY,GACC,KAAK3C,KADN,CACZ2C,QADY;AAEpB,aAAO/C,MAAM,IAAI,CAACT,MAAX,IAAqB,CAACwD,QAA7B;AACH;;;WAED,0BAAkB;AAAA,yBACqD,KAAK3C,KAD1D;AAAA,UACNoB,aADM,gBACNA,aADM;AAAA,UACSa,cADT,gBACSA,cADT;AAAA,UACyB2E,uBADzB,gBACyBA,uBADzB;AAEd,aAAOxF,aAAa,IAAI,CAACa,cAAlB,IAAoC2E,uBAA3C;AACH;;;WAED,uBAAe;AAAA,yBACwB,KAAK5G,KAD7B;AAAA,UACH6G,IADG,gBACHA,IADG;AAAA,UACGjF,UADH,gBACGA,UADH;AAAA,UACekF,IADf,gBACeA,IADf;AAEX,aAAOlF,UAAU,IAAIkF,IAAd,IAAsBD,IAAtB,IAA8BA,IAAI,CAAChC,MAAnC,IAA6CgC,IAAI,CAAChC,MAAL,GAAc,CAAlE;AACH;;;WAED,gCAA0C;AAAA,UAApB7E,KAAoB,uEAAZ,KAAKA,KAAO;AAAA,UAC9B+G,oBAD8B,GAC2D/G,KAD3D,CAC9B+G,oBAD8B;AAAA,UACRC,kBADQ,GAC2DhH,KAD3D,CACRgH,kBADQ;AAAA,UACYC,kBADZ,GAC2DjH,KAD3D,CACYiH,kBADZ;AAAA,UACgCC,sBADhC,GAC2DlH,KAD3D,CACgCkH,sBADhC;AAEtC,aAAOH,oBAAoB,GAAG,CAAvB,IACHC,kBAAkB,GAAG,CADlB,IAEH,CAAC,CAACC,kBAFC,IAGH,CAAC,CAACC,sBAHC,IAIH,KAAKC,qBAAL,EAJG,IAKH,KAAKT,qBAAL,EALG,IAMH,KAAKC,sBAAL,EANJ;AAOH;;;WAED,qCAA6B;AAAA,UACjBS,sBADiB,GACU,KAAKpH,KADf,CACjBoH,sBADiB;AAEzB,aAAO,CAAC,CAACA,sBAAF,IAA4B,CAAC,KAAKV,qBAAL,EAA7B,IAA6D,CAAC,KAAKC,sBAAL,EAArE;AACH;;;WAED,iCAAyB;AAAA,yBACkB,KAAK3G,KADvB;AAAA,UACbqH,kBADa,gBACbA,kBADa;AAAA,UACOC,MADP,gBACOA,MADP;AAErB,aAAOA,MAAM,KAAK,SAAX,IAAwBD,kBAAkB,KAAK,CAAtD;AACH;;;WAED,iCAAyB;AACrB,aAAO,KAAKrH,KAAL,CAAWsH,MAAX,KAAsB,OAA7B;AACH;;;WAED,kCAA0B;AACtB,aAAO,KAAKtH,KAAL,CAAWsH,MAAX,KAAsB,QAA7B;AACH;;;WAED,0BAAoC;AAAA,UAApBtH,KAAoB,uEAAZ,KAAKA,KAAO;AAAA,UACxB6G,IADwB,GACI7G,KADJ,CACxB6G,IADwB;AAAA,UAClBU,iBADkB,GACIvH,KADJ,CAClBuH,iBADkB;AAEhC,UAAMC,UAAU,GAAGX,IAAI,IAAIA,IAAI,CAAChC,MAAhC;;AAEA,UAAI,CAAC2C,UAAL,EAAiB;AACb,eAAO,EAAP;AACH;;AAED,UAAI,CAAC,KAAKC,WAAL,EAAL,EAAyB;AACrB,eAAOZ,IAAP;AACH;;AAED,UAAIa,aAAa,GAAG,EAApB;AACA,UAAIC,SAAS,GAAG,EAAhB;;AAEA,UAAIJ,iBAAiB,GAAGC,UAAxB,EAAoC;AAAA;;AAChC,YAAMI,cAAc,GAAGC,IAAI,CAACC,KAAL,CAAWP,iBAAiB,GAAGC,UAA/B,CAAvB;AACA,YAAMO,SAAS,GAAGR,iBAAiB,GAAGC,UAAtC;;AAEA,aAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,cAApB,EAAoCI,CAAC,EAArC,EAAyC;AAAA;;AACrC,4BAAAN,aAAa,EAACnB,IAAd,0CAAsBM,IAAtB;;AACA,wBAAAc,SAAS,EAACpB,IAAV,sCAAkBM,IAAlB;AACH;;AAED,2BAAAa,aAAa,EAACO,OAAd,2CAAyBpB,IAAI,CAACqB,KAAL,CAAW,CAACH,SAAZ,CAAzB;;AACA,uBAAAJ,SAAS,EAACpB,IAAV,uCAAkBM,IAAI,CAACqB,KAAL,CAAW,CAAX,EAAcH,SAAd,CAAlB;AACH,OAXD,MAWO;AACHL,QAAAA,aAAa,GAAGb,IAAI,CAACqB,KAAL,CAAW,CAACX,iBAAZ,CAAhB;AACAI,QAAAA,SAAS,GAAGd,IAAI,CAACqB,KAAL,CAAW,CAAX,EAAcX,iBAAd,CAAZ;AACH;;AAED,aAAOG,aAAa,CAACS,MAAd,CAAqBtB,IAArB,EAA2Bc,SAA3B,CAAP;AACH;;;WAED,gCAA0C;AAAA,UAApB3H,KAAoB,uEAAZ,KAAKA,KAAO;AAAA,UAC9B6G,IAD8B,GACF7G,KADE,CAC9B6G,IAD8B;AAAA,UACxBU,iBADwB,GACFvH,KADE,CACxBuH,iBADwB;AAEtC,UAAMC,UAAU,GAAGX,IAAI,IAAIA,IAAI,CAAChC,MAAhC;;AAEA,UAAI,CAAC2C,UAAL,EAAiB;AACb,eAAO,CAAP;AACH;;AAED,aAAO,KAAKC,WAAL,KAAqBD,UAAU,GAAI,IAAID,iBAAvC,GAA4DC,UAAnE;AACH;;;WAED,yBAAiBY,KAAjB,EAA4C;AAAA,UAApBpI,KAAoB,uEAAZ,KAAKA,KAAO;;AACxC,UAAMmE,WAAW,GAAG,KAAKC,oBAAL,CAA0BpE,KAA1B,CAApB;;AAEA,UAAI,CAACmE,WAAD,IAAiB,CAACiE,KAAD,IAAUA,KAAK,KAAK,CAAzC,EAA6C;AACzC,eAAO,CAAP;AACH;;AAED,aAAO,KAAKC,oBAAL,KAA8BlE,WAAW,GAAGiE,KAAd,GAAsB,CAApD,GAAwDA,KAA/D;AACH;;;WAED,uBAAeA,KAAf,EAAsB;AAAA,yBACkB,KAAKpI,KADvB;AAAA,UACV6G,IADU,gBACVA,IADU;AAAA,UACJU,iBADI,gBACJA,iBADI;AAElB,UAAMC,UAAU,GAAGX,IAAI,IAAIA,IAAI,CAAChC,MAAhC;;AAEA,UAAI,CAAC,KAAK4C,WAAL,EAAD,IAAuB,CAACD,UAA5B,EAAwC;AACpC,eAAOY,KAAP;AACH;;AAED,UAAIA,KAAK,IAAIZ,UAAU,GAAGD,iBAA1B,EAA6C;AACzC,eAAOA,iBAAiB,GAAGC,UAApB,GACH,CAACY,KAAK,GAAGb,iBAAT,IAA8BC,UAD3B,GAEHY,KAAK,GAAGZ,UAAR,GAAqBD,iBAFzB;AAGH,OAJD,MAIO,IAAIa,KAAK,GAAGb,iBAAZ,EAA+B;AAElC,YAAIA,iBAAiB,GAAGC,UAAxB,EAAoC;AAChC,cAAMc,eAAe,GAAG,EAAxB;AACA,cAAMC,WAAW,GAAG,EAApB;AACA,cAAMX,cAAc,GAAGC,IAAI,CAACC,KAAL,CAAWP,iBAAiB,GAAGC,UAA/B,CAAvB;AACA,cAAMO,SAAS,GAAGR,iBAAiB,GAAGC,UAAtC;;AAEA,eAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,UAApB,EAAgCQ,CAAC,EAAjC,EAAqC;AACjCM,YAAAA,eAAe,CAAC/B,IAAhB,CAAqByB,CAArB;AACH;;AAED,eAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,cAApB,EAAoCY,CAAC,EAArC,EAAyC;AACrCD,YAAAA,WAAW,CAAChC,IAAZ,OAAAgC,WAAW,EAASD,eAAT,CAAX;AACH;;AAEDC,UAAAA,WAAW,CAACN,OAAZ,OAAAM,WAAW,qBAAYD,eAAe,CAACJ,KAAhB,CAAsB,CAACH,SAAvB,CAAZ,EAAX;AACA,iBAAOQ,WAAW,CAACH,KAAD,CAAlB;AACH,SAhBD,MAgBO;AACH,iBAAOA,KAAK,GAAGZ,UAAR,GAAqBD,iBAA5B;AACH;AACJ,OArBM,MAqBA;AACH,eAAOa,KAAK,GAAGb,iBAAf;AACH;AACJ;;;WAGD,2BAAmBa,KAAnB,EAA0B;AAAA,yBACc,KAAKpI,KADnB;AAAA,UACd8G,IADc,gBACdA,IADc;AAAA,UACRS,iBADQ,gBACRA,iBADQ;AAEtB,aAAOT,IAAI,GAAGsB,KAAK,GAAGb,iBAAX,GAA+Ba,KAA1C;AACH;;;WAED,uBAAeA,KAAf,EAA0C;AAAA,UAApBpI,KAAoB,uEAAZ,KAAKA,KAAO;AAAA,UAC9BuH,iBAD8B,GACRvH,KADQ,CAC9BuH,iBAD8B;;AAEtC,UAAMpD,WAAW,GAAG,KAAKC,oBAAL,CAA0BpE,KAA1B,CAApB;;AAEA,UAAI,CAACmE,WAAD,IAAgBiE,KAAK,GAAGjE,WAAW,GAAG,CAAtC,IAA2CiE,KAAK,GAAG,CAAvD,EAA0D;AACtD,eAAO,CAAP;AACH;;AAED,aAAO,KAAKX,WAAL,KAAqBW,KAAK,GAAGb,iBAA7B,GAAiDa,KAAxD;AACH;;;WAED,0BAAkB;AACd,UAAI,KAAKK,YAAL,KACC,KAAKC,gBAAL,MAA2B,KAAKD,YAAL,CAAkBE,QAA9C,IACC,CAAC,KAAKD,gBAAL,EAAD,IAA4B,KAAKD,YAAL,CAAkBG,cAF/C,CAAJ,EAGG;AACC,eAAO,KAAKH,YAAZ;AACH;;AAGD,aAAO,KAAKA,YAAL,IAAqB,KAAKA,YAAL,CAAkBI,OAAvC,IAAkD,KAAKJ,YAAL,CAAkBI,OAAlB,EAAzD;AACH;;;WAED,6BAAqB;AACjB,aAAO,KAAK1H,cAAZ;AACH;;;WAED,6BAAyC;AAAA,UAAtBC,aAAsB,uEAAN,IAAM;;AACrC,UAAM0H,UAAU,GAAG,KAAKC,cAAL,EAAnB;;AAEA,UAAI,CAACD,UAAD,IAAe,CAACA,UAAU,CAACE,cAA/B,EAA+C;AAC3C;AACH;;AAIDF,MAAAA,UAAU,CAACE,cAAX,CAA0B;AAAE5H,QAAAA,aAAa,EAAbA;AAAF,OAA1B;AACA,WAAKD,cAAL,GAAsBC,aAAtB;AACH;;;WAED,0BAAkB6H,IAAlB,EAAwBb,KAAxB,EAA+B;AAC3B,aAAO,KAAKM,gBAAL,0BAA6CN,KAA7C,sBAAwEA,KAA/E;AACH;;;WAED,0BAAkB3B,KAAlB,EAAyB;AAAA,UACb9D,QADa,GACA,KAAK3C,KADL,CACb2C,QADa;AAErB,aAAQ8D,KAAK,IAAIA,KAAK,CAACX,WAAf,IAA8BW,KAAK,CAACX,WAAN,CAAkBC,aAAhD,IACJU,KAAK,CAACX,WAAN,CAAkBC,aAAlB,CAAgCpD,QAAQ,GAAG,GAAH,GAAS,GAAjD,CADG,IACuD,CAD9D;AAEH;;;WAED,oCAA4C;AAAA,UAAlBuG,QAAkB,uEAAP,KAAO;AAAA,yBACqD,KAAKlJ,KAD1D;AAAA,UAChC4C,WADgC,gBAChCA,WADgC;AAAA,UACnBG,YADmB,gBACnBA,YADmB;AAAA,UACLF,SADK,gBACLA,SADK;AAAA,UACMG,UADN,gBACMA,UADN;AAAA,UACkBL,QADlB,gBACkBA,QADlB;AAAA,UAC4BwG,oBAD5B,gBAC4BA,oBAD5B;;AAGxC,UAAKA,oBAAoB,KAAK,OAAzB,IAAoC,CAACD,QAAtC,IACCC,oBAAoB,KAAK,KAAzB,IAAkCD,QADvC,EACkD;AAC9C,eAAO,CAAP;AACH,OAHD,MAGO,IAAKC,oBAAoB,KAAK,KAAzB,IAAkC,CAACD,QAApC,IACNC,oBAAoB,KAAK,OAAzB,IAAoCD,QADlC,EAC6C;AAChD,eAAOvG,QAAQ,GAAGI,YAAY,GAAGC,UAAlB,GAA+BJ,WAAW,GAAGC,SAA5D;AACH,OAHM,MAGA;AACH,eAAOF,QAAQ,GAAG,CAACI,YAAY,GAAGC,UAAhB,IAA8B,CAAjC,GAAqC,CAACJ,WAAW,GAAGC,SAAf,IAA4B,CAAhF;AACH;AACJ;;;WAED,8BAAsB;AAAA,yBAC2E,KAAK7C,KADhF;AAAA,UACV4C,WADU,gBACVA,WADU;AAAA,UACGG,YADH,gBACGA,YADH;AAAA,UACiBF,SADjB,gBACiBA,SADjB;AAAA,UAC4BG,UAD5B,gBAC4BA,UAD5B;AAAA,UACwCL,QADxC,gBACwCA,QADxC;AAAA,UACkDwG,oBADlD,gBACkDA,oBADlD;;AAGlB,UAAIA,oBAAoB,KAAK,OAA7B,EAAsC;AAClC,eAAOxG,QAAQ,GAAGK,UAAU,GAAG,CAAhB,GAAoBH,SAAS,GAAG,CAA/C;AACH,OAFD,MAEO,IAAIsG,oBAAoB,KAAK,KAA7B,EAAoC;AACvC,eAAOxG,QAAQ,GACXI,YAAY,GAAIC,UAAU,GAAG,CADlB,GAEXJ,WAAW,GAAIC,SAAS,GAAG,CAF/B;AAGH,OAJM,MAIA;AACH,eAAOF,QAAQ,GAAGI,YAAY,GAAG,CAAlB,GAAsBH,WAAW,GAAG,CAAnD;AACH;AACJ;;;WAED,oBAAYwG,MAAZ,EAAoB;AAChB,aAAOA,MAAM,GAAG,KAAKC,kBAAL,EAAT,GAAqC,KAAKC,wBAAL,EAA5C;AACH;;;WAED,wBAAgBF,MAAhB,EAAwB;AAAA,0BAC0B,KAAKpJ,KAD/B;AAAA,UACZuJ,iBADY,iBACZA,iBADY;AAAA,UACOC,cADP,iBACOA,cADP;;AAEpB,UAAMC,MAAM,GAAG,KAAKC,UAAL,CAAgBN,MAAhB,CAAf;;AACA,UAAMO,YAAY,GAAGJ,iBAAiB,IAAIC,cAA1C;;AAEA,WAAK,IAAIxB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKpH,UAAL,CAAgBiE,MAApC,EAA4CmD,CAAC,EAA7C,EAAiD;AAAA,iCACtB,KAAKpH,UAAL,CAAgBoH,CAAhB,CADsB;AAAA,YACrC4B,KADqC,sBACrCA,KADqC;AAAA,YAC9BC,GAD8B,sBAC9BA,GAD8B;;AAE7C,YAAIJ,MAAM,GAAGE,YAAT,IAAyBC,KAAzB,IAAkCH,MAAM,GAAGE,YAAT,IAAyBE,GAA/D,EAAoE;AAChE,iBAAO7B,CAAP;AACH;AACJ;;AAED,UAAM8B,SAAS,GAAG,KAAKlJ,UAAL,CAAgBiE,MAAhB,GAAyB,CAA3C;;AACA,UAAI,KAAKjE,UAAL,CAAgBkJ,SAAhB,KAA8BL,MAAM,GAAGE,YAAT,GAAwB,KAAK/I,UAAL,CAAgBkJ,SAAhB,EAA2BD,GAArF,EAA0F;AACtF,eAAOC,SAAP;AACH;;AAED,aAAO,CAAP;AACH;;;WAED,0CAAoD;AAAA;;AAAA,UAApB9J,KAAoB,uEAAZ,KAAKA,KAAO;AAAA,UACxC6G,IADwC,GACsB7G,KADtB,CACxC6G,IADwC;AAAA,UAClChE,SADkC,GACsB7C,KADtB,CAClC6C,SADkC;AAAA,UACvBG,UADuB,GACsBhD,KADtB,CACvBgD,UADuB;AAAA,UACXiE,kBADW,GACsBjH,KADtB,CACXiH,kBADW;AAAA,UACStE,QADT,GACsB3C,KADtB,CACS2C,QADT;AAEhD,UAAMoH,OAAO,GAAGpH,QAAQ,GAAGK,UAAH,GAAgBH,SAAxC;;AAEA,UAAI,CAACgE,IAAD,IAAS,CAACA,IAAI,CAAChC,MAAnB,EAA2B;AACvB;AACH;;AAED,UAAI1E,aAAa,GAAG,EAApB;AACA,WAAKS,UAAL,GAAkB,EAAlB;;AAEA,WAAKoJ,cAAL,CAAoBhK,KAApB,EAA2BiK,OAA3B,CAAmC,UAACC,QAAD,EAAW9B,KAAX,EAAqB;AACpD,YAAM+B,MAAM,GAAG,MAAI,CAACC,eAAL,CAAqBhC,KAArB,EAA4BpI,KAA5B,CAAf;;AACA,YAAIqK,aAAJ;AAEA,QAAA,MAAI,CAACzJ,UAAL,CAAgBwH,KAAhB,IAAyB;AACrBwB,UAAAA,KAAK,EAAExB,KAAK,GAAG2B,OADM;AAErBF,UAAAA,GAAG,EAAEzB,KAAK,GAAG2B,OAAR,GAAkBA;AAFF,SAAzB;;AAKA,YAAI,CAAC,MAAI,CAACO,oBAAL,CAA0BtK,KAA1B,CAAL,EAAuC;AACnCqK,UAAAA,aAAa,GAAG,IAAI7K,QAAQ,CAACoG,KAAb,CAAmB,CAAnB,CAAhB;AACH,SAFD,MAEO,IAAI,MAAI,CAAC2E,yBAAL,EAAJ,EAAsC;AACzCF,UAAAA,aAAa,GAAG,IAAI7K,QAAQ,CAACoG,KAAb,CAAmBuE,MAAM,KAAK,MAAI,CAAC5J,WAAhB,GAA8B,CAA9B,GAAkC,CAArD,CAAhB;AACH,SAFM,MAEA;AACH,cAAIiK,YAAJ;;AAEA,cAAIvD,kBAAJ,EAAwB;AACpBuD,YAAAA,YAAY,GAAGvD,kBAAkB,CAACkD,MAAD,EAASnK,KAAT,CAAjC;AACH,WAFD,MAEO,IAAI,MAAI,CAAC0G,qBAAL,EAAJ,EAAkC;AACrC8D,YAAAA,YAAY,GAAG3L,uBAAuB,CAACsL,MAAD,EAASnK,KAAT,CAAtC;AACH,WAFM,MAEA,IAAI,MAAI,CAAC2G,sBAAL,EAAJ,EAAmC;AACtC6D,YAAAA,YAAY,GAAG1L,wBAAwB,CAACqL,MAAD,EAASnK,KAAT,CAAvC;AACH;;AAED,cAAI,CAACwK,YAAD,IAAiB,CAACA,YAAY,CAACC,UAA/B,IAA6C,CAACD,YAAY,CAACE,WAA/D,EAA4E;AACxEF,YAAAA,YAAY,GAAG5L,yBAAyB,CAACuL,MAAD,EAASnK,KAAT,CAAxC;AACH;;AAEDqK,UAAAA,aAAa,GAAG,MAAI,CAAC1E,UAAL,CAAgBgF,WAAhB,iCACTH,YADS;AAEZI,YAAAA,WAAW,EAAE;AAFD,aAAhB;AAIH;;AAEDzK,QAAAA,aAAa,CAACoG,IAAd,CAAmB8D,aAAnB;AACH,OAnCD;;AAqCA,WAAK7G,QAAL,CAAc;AAAErD,QAAAA,aAAa,EAAbA;AAAF,OAAd;AACH;;;WAED,4BAAoBiI,KAApB,EAA2ByC,OAA3B,EAAoC;AAAA,UACxB1K,aADwB,GACN,KAAKF,KADC,CACxBE,aADwB;AAAA,0BAEwB,KAAKH,KAF7B;AAAA,UAExB8K,mBAFwB,iBAExBA,mBAFwB;AAAA,UAEH1D,sBAFG,iBAEHA,sBAFG;AAIhC,UAAMiD,aAAa,GAAGlK,aAAa,IAAIA,aAAa,CAACiI,KAAD,CAApD;;AAEA,UAAI,CAACiC,aAAD,IAAkBA,aAAa,KAAK,CAAxC,EAA2C;AACvC,eAAO,IAAP;AACH;;AAED,UAAMU,sBAAsB;AACxBC,QAAAA,aAAa,EAAE,KADS;AAExBtF,QAAAA,eAAe,EAAE;AAFO,SAGrB0B,sBAHqB;AAIxByD,QAAAA,OAAO,EAAEA;AAJe,QAA5B;;AAOA,aAAOrL,QAAQ,CAACyL,QAAT,CAAkB,CACrBzL,QAAQ,CAAC,QAAD,CAAR,CACI6K,aADJ,kCAESU,sBAFT;AAEiCG,QAAAA,MAAM,EAAEC,MAAM,CAACC;AAFhD,SADqB,EAKrB5L,QAAQ,CAACsL,mBAAD,CAAR,CACIT,aADJ,oBAESU,sBAFT,EALqB,CAAlB,CAAP;AAUH;;;WAED,mCAA2BM,OAA3B,EAAoCC,IAApC,EAA0C;AAAA,UAC9BnL,aAD8B,GACZ,KAAKF,KADO,CAC9BE,aAD8B;;AAEtC,UAAMgE,WAAW,GAAG,KAAKC,oBAAL,EAApB;;AACA,UAAMmH,aAAa,GAAG,KAAKnB,eAAL,CAAqBiB,OAArB,CAAtB;;AACA,UAAMG,iBAAiB,GAAG,KAAKjG,aAAL,CAAmBgG,aAAnB,CAA1B;;AACA,UAAME,UAAU,GAAG,KAAKrB,eAAL,CAAqBkB,IAArB,CAAnB;;AACA,UAAMI,cAAc,GAAG,KAAKnG,aAAL,CAAmBkG,UAAnB,CAAvB;;AACA,UAAIE,UAAU,GAAG,EAAjB;;AAGA,UAAI,KAAKlE,WAAL,EAAJ,EAAwB;AACpB,aAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG7D,WAApB,EAAiC6D,CAAC,EAAlC,EAAsC;AAClC,cAAI,KAAKzC,aAAL,CAAmByC,CAAnB,MAA0BwD,iBAA1B,IAA+CrL,aAAa,CAAC6H,CAAD,CAAhE,EAAqE;AACjE2D,YAAAA,UAAU,CAACpF,IAAX,CAAgB,KAAKqF,kBAAL,CAAwB5D,CAAxB,EAA2B,CAA3B,CAAhB;AACH,WAFD,MAEO,IAAI,KAAKzC,aAAL,CAAmByC,CAAnB,MAA0B0D,cAA1B,IAA4CvL,aAAa,CAAC6H,CAAD,CAA7D,EAAkE;AACrE2D,YAAAA,UAAU,CAACpF,IAAX,CAAgB,KAAKqF,kBAAL,CAAwB5D,CAAxB,EAA2B,CAA3B,CAAhB;AACH;AACJ;AACJ,OARD,MAQO;AACH,YAAI7H,aAAa,CAACkL,OAAD,CAAjB,EAA4B;AACxBM,UAAAA,UAAU,CAACpF,IAAX,CAAgB,KAAKqF,kBAAL,CAAwBP,OAAxB,EAAiC,CAAjC,CAAhB;AACH;;AACD,YAAIlL,aAAa,CAACmL,IAAD,CAAjB,EAAyB;AACrBK,UAAAA,UAAU,CAACpF,IAAX,CAAgB,KAAKqF,kBAAL,CAAwBN,IAAxB,EAA8B,CAA9B,CAAhB;AACH;AACJ;;AAED9L,MAAAA,QAAQ,CAACyL,QAAT,CAAkBU,UAAlB,EAA8B;AAAEE,QAAAA,YAAY,EAAE;AAAhB,OAA9B,EAAuDjC,KAAvD;AACH;;;WAED,mCAA2BxB,KAA3B,EAAkC0D,IAAlC,EAAuD;AAAA;;AAAA,UAAfC,KAAe,uEAAP,KAAO;AAAA,UAC3ClF,IAD2C,GAClC,KAAK7G,KAD6B,CAC3C6G,IAD2C;;AAGnD,UAAI,CAAC,KAAKlG,QAAN,IAAkB,CAAC,KAAK8H,YAAxB,IAAwC,CAAC,KAAK7H,UAAL,CAAgBwH,KAAhB,CAAzC,IAAoE,CAAC2D,KAAD,IAAU,KAAKtE,WAAL,EAAlF,EAAuG;AACnG;AACH;;AAED,UAAM2B,MAAM,GAAG,KAAKxI,UAAL,CAAgBwH,KAAhB,KAA0B,KAAKxH,UAAL,CAAgBwH,KAAhB,EAAuBwB,KAAhE;;AAEA,UAAI,CAACR,MAAD,IAAWA,MAAM,KAAK,CAA1B,EAA6B;AACzB;AACH;;AAED,UAAMjF,WAAW,GAAG0C,IAAI,IAAIA,IAAI,CAAChC,MAAjC;AACA,UAAMmH,SAAS,GAAGF,IAAI,IAAI3H,WAAW,KAAK,CAAxB,GAA4B,OAA5B,GAAsC,KAAxD;;AAEA,WAAK8H,SAAL,CAAe7C,MAAM,IAAI4C,SAAS,KAAK,OAAd,GAAwB,CAAC,CAAzB,GAA6B,CAAjC,CAArB,EAA0D,KAA1D;;AAEAhH,MAAAA,YAAY,CAAC,KAAKC,0BAAN,CAAZ;AACA,WAAKA,0BAAL,GAAkCnB,UAAU,CAAC,YAAM;AAC/C,QAAA,MAAI,CAACmI,SAAL,CAAe7C,MAAf,EAAuB,KAAvB;AACH,OAF2C,EAEzC,EAFyC,CAA5C;AAGH;;;WAED,uBAAe;AAAA;;AAAA,UACH8C,yBADG,GAC2B,KAAKlM,KADhC,CACHkM,yBADG;AAEXlH,MAAAA,YAAY,CAAC,KAAKM,kBAAN,CAAZ;AACA,WAAKA,kBAAL,GAA0BxB,UAAU,CAAC,YAAM;AACvC,QAAA,MAAI,CAACqI,cAAL;AACH,OAFmC,EAEjCD,yBAFiC,CAApC;;AAGA,WAAKtH,iBAAL,CAAuB,KAAvB;AACH;;;WAED,0BAAkB;AACdI,MAAAA,YAAY,CAAC,KAAKM,kBAAN,CAAZ;;AACA,WAAKV,iBAAL,CAAuB,IAAvB;AACH;;;WAED,2BAAmBwD,KAAnB,EAA0B;AAAA,0BACc,KAAKpI,KADnB;AAAA,UACd6G,IADc,iBACdA,IADc;AAAA,UACRU,iBADQ,iBACRA,iBADQ;AAEtB,UAAMC,UAAU,GAAGX,IAAI,IAAIA,IAAI,CAAChC,MAAhC;;AAEA,UAAI,CAAC,KAAK4C,WAAL,EAAD,IAAuB,CAACD,UAAxB,IACCY,KAAK,IAAIb,iBAAT,IAA8Ba,KAAK,GAAGZ,UAAU,GAAGD,iBADxD,EAC4E;AACxE;AACH;;AAED,UAAI6E,YAAY,GAAGhE,KAAnB;;AAEA,UAAIA,KAAK,IAAIZ,UAAU,GAAGD,iBAA1B,EAA6C;AACzC6E,QAAAA,YAAY,GAAGhE,KAAK,GAAGZ,UAAvB;AACH,OAFD,MAEO,IAAIY,KAAK,GAAGb,iBAAZ,EAA+B;AAClC6E,QAAAA,YAAY,GAAGhE,KAAK,GAAGZ,UAAvB;AACH;;AAED,WAAK7D,WAAL,CAAiByI,YAAjB,EAA+B,KAA/B,EAAsC,KAAtC,EAA6C,KAA7C,EAAoD,KAApD;AACH;;;WAED,mBAAWhD,MAAX,EAAoC;AAAA,UAAjBiD,QAAiB,uEAAN,IAAM;AAAA,UACxB1J,QADwB,GACX,KAAK3C,KADM,CACxB2C,QADwB;;AAEhC,UAAMmG,UAAU,GAAG,KAAKC,cAAL,EAAnB;;AAEA,UAAI,CAAC,KAAKpI,QAAN,IAAkB,CAACmI,UAAvB,EAAmC;AAC/B;AACH;;AAED,UAAMwD,eAAe,GAAG,KAAK5D,gBAAL,KAA0B;AAC9CzC,QAAAA,CAAC,EAAEtD,QAAQ,GAAG,CAAH,GAAOyG,MAD4B;AAE9CpD,QAAAA,CAAC,EAAErD,QAAQ,GAAGyG,MAAH,GAAY;AAFuB,OAA1B,GAGpB;AACAA,QAAAA,MAAM,EAANA;AADA,OAHJ;;AAMA,UAAMmD,OAAO,mCACND,eADM;AAETD,QAAAA,QAAQ,EAARA;AAFS,QAAb;;AAKA,UAAI,KAAK3D,gBAAL,EAAJ,EAA6B;AACzBI,QAAAA,UAAU,CAACH,QAAX,CAAoB4D,OAApB;AACH,OAFD,MAEO;AACHzD,QAAAA,UAAU,CAACF,cAAX,CAA0B2D,OAA1B;AACH;AACJ;;;WAED,mBAAW9F,KAAX,EAAkB;AAAA,0BAC6C,KAAKzG,KADlD;AAAA,UACNwM,oBADM,iBACNA,oBADM;AAAA,UACgBvK,cADhB,iBACgBA,cADhB;AAAA,UACgC6C,QADhC,iBACgCA,QADhC;AAGd,UAAM2H,YAAY,GAAGhG,KAAK,GAAG,KAAKiG,gBAAL,CAAsBjG,KAAtB,CAAH,GAAkC,KAAK5F,qBAAjE;;AACA,UAAMyD,cAAc,GAAG,KAAKqI,cAAL,CAAoBF,YAApB,CAAvB;;AACA,UAAMG,WAAW,GAAGtI,cAAc,KAAK,KAAKuI,aAA5C;AACA,UAAMC,gBAAgB,GAClBL,YAAY,IAAI,KAAKzL,gBAAL,GAAwBwL,oBAAxC,IACAC,YAAY,IAAI,KAAKzL,gBAAL,GAAwBwL,oBAF5C;AAIA,WAAK3L,qBAAL,GAA6B4L,YAA7B;AACA,WAAKxL,kBAAL,GAA0B,IAA1B;AACA,WAAKC,eAAL,GAAuB6L,IAAI,CAACC,GAAL,EAAvB;;AAEA,UAAI,KAAKzM,WAAL,KAAqB+D,cAArB,IAAuC,KAAKiG,yBAAL,EAA3C,EAA6E;AACzE,aAAK0C,yBAAL,CAA+B,KAAK1M,WAApC,EAAiD+D,cAAjD;AACH;;AAED,UAAIrC,cAAJ,EAAoB;AAChB+C,QAAAA,YAAY,CAAC,KAAKI,sBAAN,CAAZ;;AAEA,YAAI,KAAK7E,WAAL,KAAqB+D,cAAzB,EAAyC;AACrC,eAAK/D,WAAL,GAAmB+D,cAAnB;AACH;;AAED,YAAIsI,WAAJ,EAAiB;AACb,cAAI,KAAK9L,sBAAT,EAAiC;AAC7B,iBAAKoM,aAAL,CAAmB,KAAK3H,aAAL,CAAmBjB,cAAnB,CAAnB;AACH;;AAED,cAAIwI,gBAAgB,IAAI,KAAK/L,gBAA7B,EAA+C;AAC3C,iBAAKS,OAAL,CAAa,KAAK+D,aAAL,CAAmBjB,cAAnB,CAAb;AACH;AACJ;AACJ,OAhBD,MAgBO,IAAI,KAAK/D,WAAL,KAAqB+D,cAArB,IAAuCsI,WAA3C,EAAwD;AAC3D,YAAI,KAAK9L,sBAAT,EAAiC;AAC7B,eAAKoM,aAAL,CAAmB,KAAK3H,aAAL,CAAmBjB,cAAnB,CAAnB;AACH;;AAED,YAAIwI,gBAAJ,EAAsB;AAClB,eAAKvM,WAAL,GAAmB+D,cAAnB;;AAEA,cAAI,KAAK6I,cAAL,EAAJ,EAA2B;AACvB,iBAAKhB,cAAL;AACH;;AAED,cAAI,KAAKpL,gBAAT,EAA2B;AACvB,iBAAKS,OAAL,CAAa,KAAK+D,aAAL,CAAmBjB,cAAnB,CAAb;AACH;AACJ;AACJ;;AAED,UAAIA,cAAc,KAAK,KAAKuI,aAAxB,IACAJ,YAAY,KAAK,KAAKzL,gBAD1B,EAC4C;AACxC,aAAKoM,iBAAL,CAAuB9I,cAAvB;AACH;;AAED,UAAI,OAAOQ,QAAP,KAAoB,UAApB,IAAkC2B,KAAtC,EAA6C;AACzC3B,QAAAA,QAAQ,CAAC2B,KAAD,CAAR;AACH;AACJ;;;WAED,2CAAmCA,KAAnC,EAA0C;AAAA,UAC9B4G,gCAD8B,GACO,KAAKrN,KADZ,CAC9BqN,gCAD8B;;AAGtC,UAAIA,gCAAJ,EAAsC;AAClCA,QAAAA,gCAAgC,CAAC5G,KAAD,CAAhC;AACH;;AAED,aAAO,KAAK6G,iBAAL,EAAP;AACH;;;WAED,yBAAiB;AAAA,UACLC,YADK,GACY,KAAKvN,KADjB,CACLuN,YADK;;AAIb,UAAI,KAAKD,iBAAL,OAA6B,KAA7B,IAAsC,KAAKE,YAA/C,EAA6D;AACzD,aAAKC,aAAL;AACH;;AAED,UAAIF,YAAJ,EAAkB;AACdA,QAAAA,YAAY;AACf;AACJ;;;WAED,uBAAe;AAAA,UACHG,UADG,GACY,KAAK1N,KADjB,CACH0N,UADG;;AAGX,UAAI,KAAKJ,iBAAL,OAA6B,KAA7B,IAAsC,KAAKK,SAA3C,IAAwD,CAAC,KAAKH,YAAlE,EAAgF;AAE5E,aAAK/J,aAAL;AACH;;AAED,UAAIiK,UAAJ,EAAgB;AACZA,QAAAA,UAAU;AACb;AACJ;;;WAGD,4BAAoBjH,KAApB,EAA2B;AAAA,UACfmH,iBADe,GACO,KAAK5N,KADZ,CACf4N,iBADe;;AAGvB,UAAI,CAAC,KAAKN,iBAAL,EAAL,EAA+B;AAC3B;AACH;;AAED,WAAKO,kBAAL,GAA0B,KAAKnB,gBAAL,CAAsBjG,KAAtB,CAA1B;AACA,WAAKqH,kBAAL,GAA0B,KAAKnB,cAAL,CAAoB,KAAKkB,kBAAzB,CAA1B;AACA,WAAKrL,mBAAL,GAA2B,KAA3B;;AAGA,UAAIoL,iBAAJ,EAAuB;AACnBA,QAAAA,iBAAiB,CAACnH,KAAD,CAAjB;AACH;AACJ;;;WAGD,0BAAkBA,KAAlB,EAAyB;AAAA,UACbsH,eADa,GACO,KAAK/N,KADZ,CACb+N,eADa;;AAGrB,UAAI,KAAKtF,YAAT,EAAuB;AACnB,aAAK3G,YAAL,IAAqB,KAAKA,YAAL,EAArB;AACH;;AAED,UAAIiM,eAAJ,EAAqB;AACjBA,QAAAA,eAAe,CAACtH,KAAD,CAAf;AACH;AACJ;;;WAGD,8BAAsBA,KAAtB,EAA6B;AAAA,UACjBuH,mBADiB,GACO,KAAKhO,KADZ,CACjBgO,mBADiB;;AAGzB,UAAI,KAAKvF,YAAT,EAAuB;AACnB,aAAK3G,YAAL,IAAqB,KAAKA,YAAL,EAArB;AACH;;AAED,UAAIkM,mBAAJ,EAAyB;AACrBA,QAAAA,mBAAmB,CAACvH,KAAD,CAAnB;AACH;AACJ;;;WAED,sBAAcA,KAAd,EAAqB;AAAA;;AAAA,0BACqB,KAAKzG,KAD1B;AAAA,UACTiO,aADS,iBACTA,aADS;AAAA,UACMrM,UADN,iBACMA,UADN;;AAGjB,UAAI,KAAKY,mBAAT,EAA8B;AAE1B,aAAKA,mBAAL,GAA2B,KAA3B;AACA;AACH;;AAED,UAAI,KAAK3B,qBAAL,KAA+B,KAAKqN,gBAAxC,EAA0D;AACtD;AACH;;AAED,WAAKA,gBAAL,GAAwB,KAAKrN,qBAA7B;AACA,WAAKsN,gBAAL,GAAwB,KAAKxB,cAAL,CAAoB,KAAKuB,gBAAzB,CAAxB;;AAEA,UAAItM,UAAJ,EAAgB;AACZ,aAAKwM,WAAL,CAAiB,KAAKF,gBAAL,GAAwB,KAAKL,kBAA9C;AACH;;AAID,UAAI,KAAKF,SAAL,IAAkB,CAAC,KAAKH,YAA5B,EAA0C;AACtCxI,QAAAA,YAAY,CAAC,KAAKE,sBAAN,CAAZ;AACA,aAAKA,sBAAL,GAA8BpB,UAAU,CAAC,YAAM;AAC3C,UAAA,MAAI,CAACL,aAAL;AACH,SAFuC,EAErCwK,aAAa,GAAG,EAFqB,CAAxC;AAGH;AACJ;;;WAKD,yBAAiBxH,KAAjB,EAAwB;AAAA;;AAAA,UACZxE,cADY,GACO,KAAKjC,KADZ,CACZiC,cADY;;AAGpB,UAAIA,cAAc,IAAI9C,MAAtB,EAA8B;AAC1B6F,QAAAA,YAAY,CAAC,KAAKI,sBAAN,CAAZ;AACA,aAAKA,sBAAL,GAA8BtB,UAAU,CAAC,YAAM;AAC3C,UAAA,MAAI,CAACH,WAAL,CAAiB,MAAI,CAACpD,WAAtB;AACH,SAFuC,EAErC,GAFqC,CAAxC;AAGH;AACJ;;;WAED,mBAAWkG,KAAX,EAAkB;AAAA,UACN4H,QADM,GACO,KAAKrO,KADZ,CACNqO,QADM;;AAId,UAAI,KAAKC,iBAAT,EAA4B;AACxB,aAAKjN,8BAAL;;AACA,aAAKsC,WAAL,CAAiB,KAAKpD,WAAtB,EAAmC,KAAnC,EAA0C,KAA1C,EAAiD,KAAjD,EAAwD,KAAxD;AACH,OAHD,MAGO;AACH,aAAK+N,iBAAL,GAAyB,IAAzB;AACH;;AAED,UAAID,QAAJ,EAAc;AACVA,QAAAA,QAAQ,CAAC5H,KAAD,CAAR;AACH;AACJ;;;WAED,qBAAa8H,KAAb,EAAoB;AAAA,UACR/E,cADQ,GACW,KAAKxJ,KADhB,CACRwJ,cADQ;;AAKhB,UAAI,CAAC,KAAK2E,gBAAN,IAA0B,KAAKA,gBAAL,KAA0B,CAApD,IAAyDhP,MAA7D,EAAqE;AACjE,aAAKgP,gBAAL,GAAwB,KAAKL,kBAA7B;AACH;;AAED,UAAI,KAAKA,kBAAL,KAA4B,KAAKK,gBAArC,EAAuD;AAEnD,aAAKxK,WAAL,CAAiB,KAAKwK,gBAAtB;AACH,OAHD,MAGO;AAEH,YAAII,KAAK,GAAG,CAAZ,EAAe;AACX,cAAIA,KAAK,GAAG/E,cAAZ,EAA4B;AACxB,iBAAK7F,WAAL,CAAiB,KAAKmK,kBAAL,GAA0B,CAA3C;AACH,WAFD,MAEO;AACH,iBAAKnK,WAAL,CAAiB,KAAKwK,gBAAtB;AACH;AACJ,SAND,MAMO,IAAII,KAAK,GAAG,CAAZ,EAAe;AAClB,cAAIA,KAAK,GAAG,CAAC/E,cAAb,EAA6B;AACzB,iBAAK7F,WAAL,CAAiB,KAAKmK,kBAAL,GAA0B,CAA3C;AACH,WAFD,MAEO;AACH,iBAAKnK,WAAL,CAAiB,KAAKwK,gBAAtB;AACH;AACJ,SANM,MAMA;AAEH,eAAKxK,WAAL,CAAiB,KAAKwK,gBAAtB;AACH;AACJ;AACJ;;;WAED,qBAAa/F,KAAb,EAA8F;AAAA;;AAAA,UAA1EiE,QAA0E,uEAA/D,IAA+D;AAAA,UAAzDmC,YAAyD,uEAA1C,IAA0C;AAAA,UAApCC,OAAoC,uEAA1B,KAA0B;AAAA,UAAnBC,UAAmB,uEAAN,IAAM;AAAA,0BAC7B,KAAK1O,KADwB;AAAA,UAClFiC,cADkF,iBAClFA,cADkF;AAAA,UAClE0M,YADkE,iBAClEA,YADkE;AAAA,UACpDC,kBADoD,iBACpDA,kBADoD;;AAE1F,UAAMzK,WAAW,GAAG,KAAKC,oBAAL,EAApB;;AACA,UAAM0E,UAAU,GAAG,KAAKC,cAAL,EAAnB;;AAEA,UAAI,CAAC5E,WAAD,IAAgB,CAAC2E,UAArB,EAAiC;AAC7B;AACH;;AAED,UAAI,CAACV,KAAD,IAAUA,KAAK,GAAG,CAAtB,EAAyB;AACrBA,QAAAA,KAAK,GAAG,CAAR;AACH,OAFD,MAEO,IAAIjE,WAAW,GAAG,CAAd,IAAmBiE,KAAK,IAAIjE,WAAhC,EAA6C;AAChDiE,QAAAA,KAAK,GAAGjE,WAAW,GAAG,CAAtB;AACH;;AAED,UAAIiE,KAAK,KAAK,KAAK5H,mBAAnB,EAAwC;AACpC,aAAKA,mBAAL,GAA2B4H,KAA3B;;AAGA,YAAIsG,UAAU,IAAI,KAAKvB,cAAL,EAAlB,EAAyC;AACrC,eAAK0B,WAAL;AACH;;AAED,YAAIL,YAAJ,EAAkB;AACd,cAAII,kBAAJ,EAAwB;AACpB,iBAAK9N,sBAAL,GAA8B,IAA9B;AACH;;AAED,cAAI6N,YAAJ,EAAkB;AACd,iBAAK5N,gBAAL,GAAwB,IAAxB;AACH;AACJ;AACJ;;AAED,WAAK8L,aAAL,GAAqBzE,KAArB;AACA,WAAKpH,gBAAL,GAAwB,KAAKJ,UAAL,CAAgBwH,KAAhB,KAA0B,KAAKxH,UAAL,CAAgBwH,KAAhB,EAAuBwB,KAAzE;AACA,WAAK3I,kBAAL,GAA0B,KAA1B;;AAEA,UAAI,CAAC,KAAKD,gBAAN,IAA0B,KAAKA,gBAAL,KAA0B,CAAxD,EAA2D;AACvD;AACH;;AAED,WAAKiL,SAAL,CAAe,KAAKjL,gBAApB,EAAsCqL,QAAtC;;AAEA,WAAK6B,gBAAL,GAAwB,KAAKrN,qBAA7B;;AAEA,UAAIoB,cAAJ,EAAoB;AAEhB,YAAI,CAACwM,OAAL,EAAc;AACV,eAAKjM,mBAAL,GAA2B,IAA3B;AACH;;AAQD,YAAI4F,KAAK,KAAK,CAAV,IAAeA,KAAK,KAAKjE,WAAW,GAAG,CAA3C,EAA8C;AAC1Ca,UAAAA,YAAY,CAAC,KAAKK,gBAAN,CAAZ;AACA,eAAKA,gBAAL,GAAwBvB,UAAU,CAAC,YAAM;AACrC,gBAAI,CAAC2K,OAAD,IAAYrG,KAAK,KAAK,MAAI,CAAC7H,WAA3B,IAA0C,CAAC,MAAI,CAACU,kBAApD,EAAwE;AACpE,cAAA,MAAI,CAACS,SAAL;AACH;AACJ,WAJiC,EAI/B,GAJ+B,CAAlC;AAKH;AACJ;AACJ;;;WAED,uBAAe0G,KAAf,EAAsB;AAAA,UACVwG,kBADU,GACa,KAAK5O,KADlB,CACV4O,kBADU;;AAGlB,UAAI,CAAC,KAAKnG,YAAV,EAAwB;AACpB;AACH;;AAED,WAAK3H,sBAAL,GAA8B,KAA9B;AACA8N,MAAAA,kBAAkB,IAAIA,kBAAkB,CAACxG,KAAD,CAAxC;AACH;;;WAED,iBAASA,KAAT,EAAgB;AAAA,UACJuG,YADI,GACa,KAAK3O,KADlB,CACJ2O,YADI;;AAGZ,UAAI,CAAC,KAAKlG,YAAV,EAAwB;AACpB;AACH;;AAED,WAAK1H,gBAAL,GAAwB,KAAxB;AACA4N,MAAAA,YAAY,IAAIA,YAAY,CAACvG,KAAD,CAA5B;AACH;;;WAED,yBAAiB;AAAA;;AAAA,0BAC+B,KAAKpI,KADpC;AAAA,UACL8O,gBADK,iBACLA,gBADK;AAAA,UACab,aADb,iBACaA,aADb;AAEb,WAAKN,SAAL,GAAiB,IAAjB;;AAEA,UAAI,KAAKH,YAAT,EAAuB;AACnB;AACH;;AAEDxI,MAAAA,YAAY,CAAC,KAAKG,gBAAN,CAAZ;AACA,WAAKA,gBAAL,GAAwBrB,UAAU,CAAC,YAAM;AACrC,QAAA,MAAI,CAAC0J,YAAL,GAAoB,IAApB;AACA,QAAA,MAAI,CAACuB,iBAAL,GAAyBC,WAAW,CAAC,YAAM;AACvC,cAAI,MAAI,CAACxB,YAAT,EAAuB;AACnB,YAAA,MAAI,CAACyB,UAAL;AACH;AACJ,SAJmC,EAIjCH,gBAJiC,CAApC;AAKH,OAPiC,EAO/Bb,aAP+B,CAAlC;AAQH;;;WAED,yBAAiB;AACb,WAAKT,YAAL,GAAoB,KAApB;AACAxI,MAAAA,YAAY,CAAC,KAAKG,gBAAN,CAAZ;AACAH,MAAAA,YAAY,CAAC,KAAKE,sBAAN,CAAZ;AACAgK,MAAAA,aAAa,CAAC,KAAKH,iBAAN,CAAb;AACH;;;WAED,wBAAgB;AACZ,WAAKpB,SAAL,GAAiB,KAAjB;AACA,WAAKF,aAAL;AACH;;;WAED,oBAAYrF,KAAZ,EAAyD;AAAA,UAAtCiE,QAAsC,uEAA3B,IAA2B;AAAA,UAArBmC,YAAqB,uEAAN,IAAM;;AACrD,UAAI,CAACpG,KAAD,IAAUA,KAAK,GAAG,CAAtB,EAAyB;AACrBA,QAAAA,KAAK,GAAG,CAAR;AACH;;AAED,UAAM+G,aAAa,GAAG,KAAKC,iBAAL,CAAuBhH,KAAvB,CAAtB;;AAEA,UAAI+G,aAAa,KAAK,KAAK5O,WAA3B,EAAwC;AACpC;AACH;;AAED,WAAKoD,WAAL,CAAiBwL,aAAjB,EAAgC9C,QAAhC,EAA0CmC,YAA1C;AACH;;;WAED,sBAAkD;AAAA,UAAtCnC,QAAsC,uEAA3B,IAA2B;AAAA,UAArBmC,YAAqB,uEAAN,IAAM;;AAC9C,UAAMrK,WAAW,GAAG,KAAKC,oBAAL,EAApB;;AAEA,UAAIiL,QAAQ,GAAG,KAAK9O,WAAL,GAAmB,CAAlC;;AACA,UAAI8O,QAAQ,GAAGlL,WAAW,GAAG,CAA7B,EAAgC;AAC5B,YAAI,CAAC,KAAKsD,WAAL,EAAL,EAAyB;AACrB;AACH;;AACD4H,QAAAA,QAAQ,GAAG,CAAX;AACH;;AACD,WAAK1L,WAAL,CAAiB0L,QAAjB,EAA2BhD,QAA3B,EAAqCmC,YAArC;AACH;;;WAED,sBAAkD;AAAA,UAAtCnC,QAAsC,uEAA3B,IAA2B;AAAA,UAArBmC,YAAqB,uEAAN,IAAM;;AAC9C,UAAMrK,WAAW,GAAG,KAAKC,oBAAL,EAApB;;AAEA,UAAIiL,QAAQ,GAAG,KAAK9O,WAAL,GAAmB,CAAlC;;AACA,UAAI8O,QAAQ,GAAG,CAAf,EAAkB;AACd,YAAI,CAAC,KAAK5H,WAAL,EAAL,EAAyB;AACrB;AACH;;AACD4H,QAAAA,QAAQ,GAAGlL,WAAW,GAAG,CAAzB;AACH;;AACD,WAAKR,WAAL,CAAiB0L,QAAjB,EAA2BhD,QAA3B,EAAqCmC,YAArC;AACH;;;WAGD,8BAAsBpF,MAAtB,EAA8B;AAE1B,UAAI2D,IAAI,CAACC,GAAL,KAAa,KAAK9L,eAAlB,GAAoC,GAAxC,EAA6C;AACzC;AACH;;AAED,UAAMoO,cAAc,GAAG,KAAKzO,qBAA5B;;AACA,UAAI,CAACyO,cAAD,IAAmBA,cAAc,KAAK,CAA1C,EAA6C;AACzC;AACH;;AAED,UAAM7C,YAAY,GAAGrD,MAAM,KAAKkG,cAAc,KAAK,CAAnB,GAAuB,CAAvB,GAA2B,CAAC,CAAjC,CAA3B;;AACA,WAAKrD,SAAL,CAAeqD,cAAc,GAAG7C,YAAhC,EAA8C,KAA9C;AACH;;;WAED,oCAA4BrE,KAA5B,EAAmCiC,aAAnC,EAAkD;AAAA,0BACO,KAAKrK,KADZ;AAAA,UACtCuP,gBADsC,iBACtCA,gBADsC;AAAA,UACpBrI,sBADoB,iBACpBA,sBADoB;;AAG9C,UAAIA,sBAAJ,EAA4B;AACxB,eAAOA,sBAAsB,CAACkB,KAAD,EAAQiC,aAAR,EAAuB,KAAKrK,KAA5B,CAA7B;AACH,OAFD,MAEO,IAAI,KAAK2G,sBAAL,EAAJ,EAAmC;AACtC,eAAOzH,oBAAoB,CAACkJ,KAAD,EAAQiC,aAAR,EAAuB,KAAKrK,KAA5B,EAAmCuP,gBAAnC,CAA3B;AACH,OAFM,MAEA,IAAI,KAAK7I,qBAAL,EAAJ,EAAkC;AACrC,eAAOzH,mBAAmB,CAACmJ,KAAD,EAAQiC,aAAR,EAAuB,KAAKrK,KAA5B,EAAmCuP,gBAAnC,CAA1B;AACH,OAFM,MAEA,IAAI,KAAKpI,qBAAL,EAAJ,EAAkC;AACrC,eAAOnI,mBAAmB,CAACoJ,KAAD,EAAQiC,aAAR,EAAuB,KAAKrK,KAA5B,CAA1B;AACH,OAFM,MAEA;AACH,eAAOjB,qBAAqB,CAACqJ,KAAD,EAAQiC,aAAR,EAAuB,KAAKrK,KAA5B,CAA5B;AACH;AACJ;;;WAED,2BAA8B;AAAA,UAAfiJ,IAAe,QAAfA,IAAe;AAAA,UAATb,KAAS,QAATA,KAAS;AAAA,UAClBjI,aADkB,GACA,KAAKF,KADL,CAClBE,aADkB;AAAA,0BAYtB,KAAKH,KAZiB;AAAA,UAGtBwP,iBAHsB,iBAGtBA,iBAHsB;AAAA,UAItB3M,SAJsB,iBAItBA,SAJsB;AAAA,UAKtBG,UALsB,iBAKtBA,UALsB;AAAA,UAMtByM,YANsB,iBAMtBA,YANsB;AAAA,UAOtBC,UAPsB,iBAOtBA,UAPsB;AAAA,UAQtB3M,YARsB,iBAQtBA,YARsB;AAAA,UAStBH,WATsB,iBAStBA,WATsB;AAAA,UAUtB+M,UAVsB,iBAUtBA,UAVsB;AAAA,UAWtBhN,QAXsB,iBAWtBA,QAXsB;AAc1B,UAAM0H,aAAa,GAAGlK,aAAa,IAAIA,aAAa,CAACiI,KAAD,CAApD;;AAEA,UAAI,CAACiC,aAAD,IAAkBA,aAAa,KAAK,CAAxC,EAA2C;AACvC,eAAO,IAAP;AACH;;AAED,UAAMuF,OAAO,GAAG,KAAKtF,oBAAL,EAAhB;;AACA,UAAM9L,SAAS,GAAGoR,OAAO,GAAGpQ,QAAQ,CAACqQ,IAAZ,GAAmBA,IAA5C;AACA,UAAMC,aAAa,GAAGF,OAAO,GAAG,KAAKG,0BAAL,CAAgC3H,KAAhC,EAAuCiC,aAAvC,CAAH,GAA2D,EAAxF;AAEA,UAAM2F,aAAa,GAAGR,iBAAiB,GAAG;AACtCF,QAAAA,cAAc,EAAE,KAAK3J,UADiB;AAEtCsK,QAAAA,WAAW,EAAE,KAAKxH,YAFoB;AAGtC9F,QAAAA,QAAQ,EAARA,QAHsC;AAItCC,QAAAA,WAAW,EAAXA,WAJsC;AAKtCG,QAAAA,YAAY,EAAZA,YALsC;AAMtCF,QAAAA,SAAS,EAATA,SANsC;AAOtCG,QAAAA,UAAU,EAAVA;AAPsC,OAAH,GAQnCnB,SARJ;AAUA,UAAMqO,aAAa,GAAGvN,QAAQ,GAAG;AAAEwN,QAAAA,MAAM,EAAEnN;AAAV,OAAH,GAA4B;AAAEoN,QAAAA,KAAK,EAAEvN;AAAT,OAA1D;AACA,UAAMwN,aAAa,GAAG,KAAK3H,gBAAL,KAA0B;AAC5C4H,QAAAA,GAAG,EAAEb,YAAY,GAAGA,YAAY,CAACxG,IAAD,EAAOb,KAAP,CAAf,GAA+B,KAAK9F,gBAAL,CAAsB2G,IAAtB,EAA4Bb,KAA5B;AADJ,OAA1B,GAElB,EAFJ;AAIA,aACI,oBAAC,SAAD;AAAW,QAAA,KAAK,EAAE,CAAC8H,aAAD,EAAgBP,UAAhB,EAA4BG,aAA5B,CAAlB;AAA8D,QAAA,aAAa,EAAE;AAA7E,SAA6FO,aAA7F;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UACMX,UAAU,CAAC;AAAEzG,QAAAA,IAAI,EAAJA,IAAF;AAAQb,QAAAA,KAAK,EAALA;AAAR,OAAD,EAAkB4H,aAAlB,CADhB,CADJ;AAKH;;;WAED,yCAAiC;AAAA,0BASzB,KAAKhQ,KAToB;AAAA,UAEzBiC,cAFyB,iBAEzBA,cAFyB;AAAA,UAGzBY,SAHyB,iBAGzBA,SAHyB;AAAA,UAIzBG,UAJyB,iBAIzBA,UAJyB;AAAA,UAKzBuE,iBALyB,iBAKzBA,iBALyB;AAAA,UAMzB3E,WANyB,iBAMzBA,WANyB;AAAA,UAOzBG,YAPyB,iBAOzBA,YAPyB;AAAA,UAQzBJ,QARyB,iBAQzBA,QARyB;AAW7B,UAAM4N,YAAY,GAAG1I,IAAI,CAAC2I,IAAL,CAAU7N,QAAQ,GACnCI,YAAY,GAAGC,UADoB,GAEnCJ,WAAW,GAAGC,SAFG,IAEU,CAF/B;AAGA,UAAM4N,iBAAiB,GAAG,KAAKhJ,WAAL,KAAqBF,iBAArB,GAAyC,CAAnE;AACA,UAAMmJ,kBAAkB,GAAGH,YAAY,GAAIE,iBAAiB,GAAG,CAA/D;AACA,UAAME,mBAAmB,GAAG,IAAKD,kBAAkB,GAAG,CAAtD;AACA,UAAME,UAAU,GAAGD,mBAAnB;AAEA,UAAMN,aAAa,GAAG,CAAC,KAAK3H,gBAAL,EAAD,GAA2B;AAC7CgI,QAAAA,kBAAkB,EAAEA,kBADyB;AAE7CC,QAAAA,mBAAmB,EAAEA,mBAFwB;AAG7CC,QAAAA,UAAU,EAAEA;AAHiC,OAA3B,GAKlB,EALJ;AAOA;AACIC,QAAAA,gBAAgB,EAAE5O,cAAc,GAAG,GAAH,GAAS,MAD7C;AAEI6O,QAAAA,8BAA8B,EAAE,KAFpC;AAGIC,QAAAA,4BAA4B,EAAE,KAHlC;AAIIC,QAAAA,cAAc,EAAE,OAJpB;AAKIC,QAAAA,gCAAgC,EAAE,KALtC;AAMIC,QAAAA,sBAAsB,EAAE,IAN5B;AAOIC,QAAAA,mBAAmB,EAAE,KAPzB;AAQIC,QAAAA,YAAY,EAAE,KARlB;AASIC,QAAAA,qBAAqB,EAAE,CAAC,KAAK3I,gBAAL,EAT5B;AAUI4I,QAAAA,QAAQ,EAAE,KAAKjJ,oBAAL;AAVd,SAYOgI,aAZP;AAcH;;;WAED,oCAA4B;AAAA;;AAAA,UAChBnQ,YADgB,GACC,KAAKD,KADN,CAChBC,YADgB;AAAA,0BAUpB,KAAKF,KAVe;AAAA,UAGpBuR,oBAHoB,iBAGpBA,oBAHoB;AAAA,UAIpBC,2BAJoB,iBAIpBA,2BAJoB;AAAA,UAKpB/B,YALoB,iBAKpBA,YALoB;AAAA,UAMpB7M,WANoB,iBAMpBA,WANoB;AAAA,UAOpBG,YAPoB,iBAOpBA,YAPoB;AAAA,UAQpB0O,KARoB,iBAQpBA,KARoB;AAAA,UASpB9O,QAToB,iBASpBA,QAToB;AAYxB,UAAM+O,cAAc,GAAG,CACnBH,oBAAoB,IAAIE,KAAxB,IAAiC,EADd,EAEnBvR,YAAY,GAAG;AAAEyR,QAAAA,OAAO,EAAE;AAAX,OAAH,GAAoB,EAFb,EAGnBhP,QAAQ,GACJ;AAAEwN,QAAAA,MAAM,EAAEpN,YAAV;AAAwB6O,QAAAA,aAAa,EAAE;AAAvC,OADI,GAIJ;AAAExB,QAAAA,KAAK,EAAExN,WAAT;AAAsBgP,QAAAA,aAAa,EAAE,KAAKvJ,oBAAL,KAA8B,aAA9B,GAA8C;AAAnF,OAPe,CAAvB;AASA,UAAMwJ,qBAAqB,GAAG,CAC1BlP,QAAQ,GAAG;AACPmP,QAAAA,UAAU,EAAE,KAAKxI,wBAAL,EADL;AAEPyI,QAAAA,aAAa,EAAE,KAAKzI,wBAAL,CAA8B,IAA9B;AAFR,OAAH,GAGJ;AACA0I,QAAAA,WAAW,EAAE,KAAK1I,wBAAL,EADb;AAEA2I,QAAAA,YAAY,EAAE,KAAK3I,wBAAL,CAA8B,IAA9B;AAFd,OAJsB,EAQ1BkI,2BAA2B,IAAI,EARL,CAA9B;AAWA,UAAMnB,aAAa,GAAG,CAAC,KAAK3H,gBAAL,EAAD,GAA2B;AAE7CgH,QAAAA,UAAU,EAAE,KAAKnO,WAF4B;AAG7C2Q,QAAAA,UAAU,EAAE,CAHiC;AAI7CzC,QAAAA,YAAY,EAAEA,YAAY,IAAI,KAAKnN;AAJU,OAA3B,GAKlB,EALJ;AAOA;AACI6P,QAAAA,GAAG,EAAE,aAAAC,CAAC;AAAA,iBAAI,OAAI,CAAC3J,YAAL,GAAoB2J,CAAxB;AAAA,SADV;AAEIvL,QAAAA,IAAI,EAAE,KAAKmD,cAAL,EAFV;AAGIyH,QAAAA,KAAK,EAAEC,cAHX;AAIIG,QAAAA,qBAAqB,EAAEA,qBAJ3B;AAKIQ,QAAAA,UAAU,EAAE,CAAC1P,QALjB;AAMI2P,QAAAA,mBAAmB,EAAE,CANzB;AAOIxN,QAAAA,QAAQ,EAAE,KAAK0B,gBAPnB;AAQIoH,QAAAA,iBAAiB,EAAE,KAAKjM,kBAR5B;AASIoM,QAAAA,eAAe,EAAE,KAAK/L,gBAT1B;AAUIgM,QAAAA,mBAAmB,EAAE,KAAK9L,oBAV9B;AAWIqQ,QAAAA,kBAAkB,EAAE,KAAKlQ,eAX7B;AAYIgL,QAAAA,gCAAgC,EAAE,KAAKmF,iCAZ3C;AAaIjF,QAAAA,YAAY,EAAE,KAAKpL,aAbvB;AAcIuL,QAAAA,UAAU,EAAE,KAAK5L,YAdrB;AAeIuM,QAAAA,QAAQ,EAAE,KAAK5M;AAfnB,SAgBO4O,aAhBP;AAkBH;;;WAED,kBAAU;AAAA;;AAAA,0BACsC,KAAKrQ,KAD3C;AAAA,UACE6G,IADF,iBACEA,IADF;AAAA,UACQ6I,UADR,iBACQA,UADR;AAAA,UACoBxM,aADpB,iBACoBA,aADpB;;AAGN,UAAI,CAAC2D,IAAD,IAAS,CAAC6I,UAAd,EAA0B;AACtB,eAAO,IAAP;AACH;;AAED,UAAM1P,KAAK,iDACJ,KAAKyS,6BAAL,EADI,GAEJ,KAAKzS,KAFD,GAGJ,KAAK0S,wBAAL,EAHI,CAAX;;AAMA,UAAMC,mBAAmB,GAAG,OAAOzP,aAAP,KAAyB,UAAzB,GAAsCA,aAAtC,GAAsDxD,kBAAlF;AAEA,aAAO,KAAKgJ,gBAAL,KACH,oBAAC,mBAAD,eAAyB1I,KAAzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAEQ,KAAKgK,cAAL,GAAsB4I,GAAtB,CAA0B,UAAC3J,IAAD,EAAOb,KAAP,EAAiB;AACvC,eAAO,OAAI,CAAC7G,WAAL,CAAiB;AAAE0H,UAAAA,IAAI,EAAJA,IAAF;AAAQb,UAAAA,KAAK,EAALA;AAAR,SAAjB,CAAP;AACH,OAFD,CAFR,CADG,GASH,oBAAC,gBAAD,eAAsBpI,KAAtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SATJ;AAWH;;;;EA9zCiCxB,S;;AAAjBuB,Q,CAEV8S,S,GAAY;AACfhM,EAAAA,IAAI,EAAEnI,SAAS,CAACoU,KAAV,CAAgBC,UADP;AAEfrD,EAAAA,UAAU,EAAEhR,SAAS,CAACsU,IAAV,CAAeD,UAFZ;AAGflQ,EAAAA,SAAS,EAAEnE,SAAS,CAACuU,MAHN;AAIfjQ,EAAAA,UAAU,EAAEtE,SAAS,CAACuU,MAJP;AAKfrQ,EAAAA,WAAW,EAAElE,SAAS,CAACuU,MALR;AAMflQ,EAAAA,YAAY,EAAErE,SAAS,CAACuU,MANT;AAOfnI,EAAAA,mBAAmB,EAAEpM,SAAS,CAACwU,MAPhB;AAQf9L,EAAAA,sBAAsB,EAAE1I,SAAS,CAACyU,MARnB;AASfhK,EAAAA,oBAAoB,EAAEzK,SAAS,CAAC0U,KAAV,CAAgB,CAAC,QAAD,EAAW,KAAX,EAAkB,OAAlB,CAAhB,CATP;AAUf7J,EAAAA,iBAAiB,EAAE7K,SAAS,CAACuU,MAVd;AAWfhQ,EAAAA,eAAe,EAAEvE,SAAS,CAACuU,MAXZ;AAYflR,EAAAA,QAAQ,EAAErD,SAAS,CAAC2U,IAZL;AAafpF,EAAAA,aAAa,EAAEvP,SAAS,CAACuU,MAbV;AAcfnE,EAAAA,gBAAgB,EAAEpQ,SAAS,CAACuU,MAdb;AAefzG,EAAAA,oBAAoB,EAAE9N,SAAS,CAACuU,MAfjB;AAgBf1B,EAAAA,oBAAoB,EAAE9S,aAAa,GAAGA,aAAa,CAACgT,KAAjB,GAAyB5B,IAAI,CAACgD,SAAL,CAAepB,KAhB5D;AAiBfD,EAAAA,2BAA2B,EAAE/S,aAAa,GAAGA,aAAa,CAACgT,KAAjB,GAAyB5B,IAAI,CAACgD,SAAL,CAAepB,KAjBnE;AAkBfxP,EAAAA,cAAc,EAAEvD,SAAS,CAAC2U,IAlBX;AAmBfzR,EAAAA,UAAU,EAAElD,SAAS,CAAC2U,IAnBP;AAoBf/S,EAAAA,SAAS,EAAE5B,SAAS,CAACuU,MApBN;AAqBfzD,EAAAA,iBAAiB,EAAE9Q,SAAS,CAAC2U,IArBd;AAsBftM,EAAAA,oBAAoB,EAAErI,SAAS,CAACuU,MAtBjB;AAuBfjM,EAAAA,kBAAkB,EAAEtI,SAAS,CAACuU,MAvBf;AAwBf5L,EAAAA,kBAAkB,EAAE3I,SAAS,CAACuU,MAxBf;AAyBf3L,EAAAA,MAAM,EAAE5I,SAAS,CAAC0U,KAAV,CAAgB,CAAC,SAAD,EAAY,OAAZ,EAAqB,QAArB,CAAhB,CAzBO;AA0Bf7D,EAAAA,gBAAgB,EAAE7Q,SAAS,CAACuU,MA1Bb;AA2Bf/G,EAAAA,yBAAyB,EAAExN,SAAS,CAACuU,MA3BtB;AA4BfrM,EAAAA,uBAAuB,EAAElI,SAAS,CAAC2U,IA5BpB;AA6BfvM,EAAAA,IAAI,EAAEpI,SAAS,CAAC2U,IA7BD;AA8Bf9L,EAAAA,iBAAiB,EAAE7I,SAAS,CAACuU,MA9Bd;AA+Bf7R,EAAAA,aAAa,EAAE1C,SAAS,CAAC2U,IA/BV;AAgCfpM,EAAAA,kBAAkB,EAAEvI,SAAS,CAACsU,IAhCf;AAiCf9L,EAAAA,sBAAsB,EAAExI,SAAS,CAACsU,IAjCnB;AAkCfrD,EAAAA,UAAU,EAAElR,aAAa,GAAGA,aAAa,CAACgT,KAAjB,GAAyB5B,IAAI,CAACgD,SAAL,CAAepB,KAlClD;AAmCfxN,EAAAA,qBAAqB,EAAEvF,SAAS,CAAC2U,IAnClB;AAoCf7J,EAAAA,cAAc,EAAE9K,SAAS,CAACuU,MApCX;AAqCf/P,EAAAA,aAAa,EAAExE,SAAS,CAAC4U,SAAV,CAAoB,CAAC5U,SAAS,CAAC2U,IAAX,EAAiB3U,SAAS,CAACsU,IAA3B,CAApB,CArCA;AAsCfrQ,EAAAA,QAAQ,EAAEjE,SAAS,CAAC2U,IAtCL;AAuCfzE,EAAAA,kBAAkB,EAAElQ,SAAS,CAACsU,IAvCf;AAwCfrE,EAAAA,YAAY,EAAEjQ,SAAS,CAACsU;AAxCT,C;AAFFjT,Q,CA6CVwT,Y,GAAe;AAClBzI,EAAAA,mBAAmB,EAAE,QADH;AAElB1D,EAAAA,sBAAsB,EAAE,IAFN;AAGlB+B,EAAAA,oBAAoB,EAAE,QAHJ;AAIlBI,EAAAA,iBAAiB,EAAE,EAJD;AAKlBtG,EAAAA,eAAe,EAAE,CALC;AAMlBlB,EAAAA,QAAQ,EAAE,KANQ;AAOlBkM,EAAAA,aAAa,EAAE,IAPG;AAQlBa,EAAAA,gBAAgB,EAAE,IARA;AASlBtC,EAAAA,oBAAoB,EAAE,CATJ;AAUlB+E,EAAAA,oBAAoB,EAAE,EAVJ;AAWlBC,EAAAA,2BAA2B,EAAE,EAXX;AAYlBvP,EAAAA,cAAc,EAAE,KAZE;AAalBL,EAAAA,UAAU,EAAE,IAbM;AAclBtB,EAAAA,SAAS,EAAE,CAdO;AAelBkP,EAAAA,iBAAiB,EAAE,KAfD;AAgBlBzI,EAAAA,oBAAoB,EAAE,GAhBJ;AAiBlBC,EAAAA,kBAAkB,EAAE,GAjBF;AAkBlBK,EAAAA,kBAAkB,EAAE,CAlBF;AAmBlBC,EAAAA,MAAM,EAAE,SAnBU;AAoBlB4E,EAAAA,yBAAyB,EAAE,IApBT;AAqBlBtF,EAAAA,uBAAuB,EAAE,KArBP;AAsBlBE,EAAAA,IAAI,EAAE,KAtBY;AAuBlBS,EAAAA,iBAAiB,EAAE,CAvBD;AAwBlBnG,EAAAA,aAAa,EAAE,IAxBG;AAyBlBuO,EAAAA,UAAU,EAAE,EAzBM;AA0BlB1L,EAAAA,qBAAqB,EAAE,IA1BL;AA2BlBuF,EAAAA,cAAc,EAAE,EA3BE;AA4BlBtG,EAAAA,aAAa,EAAE,CAAC5D,gBA5BE;AA6BlBqD,EAAAA,QAAQ,EAAE;AA7BQ,C;SA7CL5C,Q","sourcesContent":["import React, { Component } from 'react';\nimport { Animated, Easing, FlatList, I18nManager, Platform, ScrollView, View, ViewPropTypes } from 'react-native';\nimport PropTypes from 'prop-types';\nimport shallowCompare from 'react-addons-shallow-compare';\nimport {\n    defaultScrollInterpolator,\n    stackScrollInterpolator,\n    tinderScrollInterpolator,\n    defaultAnimatedStyles,\n    shiftAnimatedStyles,\n    stackAnimatedStyles,\n    tinderAnimatedStyles\n} from '../utils/animations';\n\nconst IS_IOS = Platform.OS === 'ios';\n\n// Native driver for scroll events\n// See: https://facebook.github.io/react-native/blog/2017/02/14/using-native-driver-for-animated.html\nconst AnimatedFlatList = FlatList ? Animated.createAnimatedComponent(FlatList) : null;\nconst AnimatedScrollView = Animated.createAnimatedComponent(ScrollView);\n\n// React Native automatically handles RTL layouts; unfortunately, it's buggy with horizontal ScrollView\n// See https://github.com/facebook/react-native/issues/11960\n// NOTE: the following variable is not declared in the constructor\n// otherwise it is undefined at init, which messes with custom indexes\nconst IS_RTL = I18nManager.isRTL;\n\nexport default class Carousel extends Component {\n\n    static propTypes = {\n        data: PropTypes.array.isRequired,\n        renderItem: PropTypes.func.isRequired,\n        itemWidth: PropTypes.number, // required for horizontal carousel\n        itemHeight: PropTypes.number, // required for vertical carousel\n        sliderWidth: PropTypes.number, // required for horizontal carousel\n        sliderHeight: PropTypes.number, // required for vertical carousel\n        activeAnimationType: PropTypes.string,\n        activeAnimationOptions: PropTypes.object,\n        activeSlideAlignment: PropTypes.oneOf(['center', 'end', 'start']),\n        activeSlideOffset: PropTypes.number,\n        apparitionDelay: PropTypes.number,\n        autoplay: PropTypes.bool,\n        autoplayDelay: PropTypes.number,\n        autoplayInterval: PropTypes.number,\n        callbackOffsetMargin: PropTypes.number,\n        containerCustomStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n        contentContainerCustomStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n        enableMomentum: PropTypes.bool,\n        enableSnap: PropTypes.bool,\n        firstItem: PropTypes.number,\n        hasParallaxImages: PropTypes.bool,\n        inactiveSlideOpacity: PropTypes.number,\n        inactiveSlideScale: PropTypes.number,\n        inactiveSlideShift: PropTypes.number,\n        layout: PropTypes.oneOf(['default', 'stack', 'tinder']),\n        layoutCardOffset: PropTypes.number,\n        lockScrollTimeoutDuration: PropTypes.number,\n        lockScrollWhileSnapping: PropTypes.bool,\n        loop: PropTypes.bool,\n        loopClonesPerSide: PropTypes.number,\n        scrollEnabled: PropTypes.bool,\n        scrollInterpolator: PropTypes.func,\n        slideInterpolatedStyle: PropTypes.func,\n        slideStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n        shouldOptimizeUpdates: PropTypes.bool,\n        swipeThreshold: PropTypes.number,\n        useScrollView: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n        vertical: PropTypes.bool,\n        onBeforeSnapToItem: PropTypes.func,\n        onSnapToItem: PropTypes.func\n    };\n\n    static defaultProps = {\n        activeAnimationType: 'timing',\n        activeAnimationOptions: null,\n        activeSlideAlignment: 'center',\n        activeSlideOffset: 20,\n        apparitionDelay: 0,\n        autoplay: false,\n        autoplayDelay: 1000,\n        autoplayInterval: 3000,\n        callbackOffsetMargin: 5,\n        containerCustomStyle: {},\n        contentContainerCustomStyle: {},\n        enableMomentum: false,\n        enableSnap: true,\n        firstItem: 0,\n        hasParallaxImages: false,\n        inactiveSlideOpacity: 0.7,\n        inactiveSlideScale: 0.9,\n        inactiveSlideShift: 0,\n        layout: 'default',\n        lockScrollTimeoutDuration: 1000,\n        lockScrollWhileSnapping: false,\n        loop: false,\n        loopClonesPerSide: 3,\n        scrollEnabled: true,\n        slideStyle: {},\n        shouldOptimizeUpdates: true,\n        swipeThreshold: 20,\n        useScrollView: !AnimatedFlatList,\n        vertical: false\n    }\n\n    constructor (props) {\n        super(props);\n\n        this.state = {\n            hideCarousel: true,\n            interpolators: []\n        };\n\n        // The following values are not stored in the state because 'setState()' is asynchronous\n        // and this results in an absolutely crappy behavior on Android while swiping (see #156)\n        const initialActiveItem = this._getFirstItem(props.firstItem);\n        this._activeItem = initialActiveItem;\n        this._previousActiveItem = initialActiveItem;\n        this._previousFirstItem = initialActiveItem;\n        this._previousItemsLength = initialActiveItem;\n\n        this._mounted = false;\n        this._positions = [];\n        this._currentContentOffset = 0; // store ScrollView's scroll position\n        this._canFireBeforeCallback = false;\n        this._canFireCallback = false;\n        this._scrollOffsetRef = null;\n        this._onScrollTriggered = true; // used when momentum is enabled to prevent an issue with edges items\n        this._lastScrollDate = 0; // used to work around a FlatList bug\n        this._scrollEnabled = props.scrollEnabled !== false;\n\n        this._initPositionsAndInterpolators = this._initPositionsAndInterpolators.bind(this);\n        this._renderItem = this._renderItem.bind(this);\n        this._onSnap = this._onSnap.bind(this);\n\n        this._onLayout = this._onLayout.bind(this);\n        this._onScroll = this._onScroll.bind(this);\n        this._onScrollBeginDrag = props.enableSnap ? this._onScrollBeginDrag.bind(this) : undefined;\n        this._onScrollEnd = props.enableSnap || props.autoplay ? this._onScrollEnd.bind(this) : undefined;\n        this._onScrollEndDrag = !props.enableMomentum ? this._onScrollEndDrag.bind(this) : undefined;\n        this._onMomentumScrollEnd = props.enableMomentum ? this._onMomentumScrollEnd.bind(this) : undefined;\n        this._onTouchStart = this._onTouchStart.bind(this);\n        this._onTouchEnd = this._onTouchEnd.bind(this);\n        this._onTouchRelease = this._onTouchRelease.bind(this);\n\n        this._getKeyExtractor = this._getKeyExtractor.bind(this);\n\n        this._setScrollHandler(props);\n\n        // This bool aims at fixing an iOS bug due to scrollTo that triggers onMomentumScrollEnd.\n        // onMomentumScrollEnd fires this._snapScroll, thus creating an infinite loop.\n        this._ignoreNextMomentum = false;\n\n        // Warnings\n        if (!ViewPropTypes) {\n            console.warn('react-native-snap-carousel: It is recommended to use at least version 0.44 of React Native with the plugin');\n        }\n        if (!props.vertical && (!props.sliderWidth || !props.itemWidth)) {\n            console.error('react-native-snap-carousel: You need to specify both `sliderWidth` and `itemWidth` for horizontal carousels');\n        }\n        if (props.vertical && (!props.sliderHeight || !props.itemHeight)) {\n            console.error('react-native-snap-carousel: You need to specify both `sliderHeight` and `itemHeight` for vertical carousels');\n        }\n        if (props.apparitionDelay && !IS_IOS && !props.useScrollView) {\n            console.warn('react-native-snap-carousel: Using `apparitionDelay` on Android is not recommended since it can lead to rendering issues');\n        }\n        if (props.customAnimationType || props.customAnimationOptions) {\n            console.warn('react-native-snap-carousel: Props `customAnimationType` and `customAnimationOptions` have been renamed to `activeAnimationType` and `activeAnimationOptions`');\n        }\n        if (props.onScrollViewScroll) {\n            console.error('react-native-snap-carousel: Prop `onScrollViewScroll` has been removed. Use `onScroll` instead');\n        }\n    }\n\n    componentDidMount () {\n        const { apparitionDelay, autoplay, firstItem } = this.props;\n        const _firstItem = this._getFirstItem(firstItem);\n        const apparitionCallback = () => {\n            this.setState({ hideCarousel: false });\n            if (autoplay) {\n                this.startAutoplay();\n            }\n        };\n\n        this._mounted = true;\n        this._initPositionsAndInterpolators();\n\n        // Without 'requestAnimationFrame' or a `0` timeout, images will randomly not be rendered on Android...\n        requestAnimationFrame(() => {\n            if (!this._mounted) {\n                return;\n            }\n\n            this._snapToItem(_firstItem, false, false, true, false);\n            this._hackActiveSlideAnimation(_firstItem, 'start', true);\n\n            if (apparitionDelay) {\n                this._apparitionTimeout = setTimeout(() => {\n                    apparitionCallback();\n                }, apparitionDelay);\n            } else {\n                apparitionCallback();\n            }\n        });\n    }\n\n    shouldComponentUpdate (nextProps, nextState) {\n        if (this.props.shouldOptimizeUpdates === false) {\n            return true;\n        } else {\n            return shallowCompare(this, nextProps, nextState);\n        }\n    }\n\n    componentDidUpdate (prevProps) {\n        const { interpolators } = this.state;\n        const { firstItem, itemHeight, itemWidth, scrollEnabled, sliderHeight, sliderWidth } = this.props;\n        const itemsLength = this._getCustomDataLength(this.props);\n\n        if (!itemsLength) {\n            return;\n        }\n\n        const nextFirstItem = this._getFirstItem(firstItem, this.props);\n        let nextActiveItem = this._activeItem || this._activeItem === 0 ? this._activeItem : nextFirstItem;\n\n        const hasNewSliderWidth = sliderWidth && sliderWidth !== prevProps.sliderWidth;\n        const hasNewSliderHeight = sliderHeight && sliderHeight !== prevProps.sliderHeight;\n        const hasNewItemWidth = itemWidth && itemWidth !== prevProps.itemWidth;\n        const hasNewItemHeight = itemHeight && itemHeight !== prevProps.itemHeight;\n        const hasNewScrollEnabled = scrollEnabled !== prevProps.scrollEnabled;\n\n        // Prevent issues with dynamically removed items\n        if (nextActiveItem > itemsLength - 1) {\n            nextActiveItem = itemsLength - 1;\n        }\n\n        // Handle changing scrollEnabled independent of user -> carousel interaction\n        if (hasNewScrollEnabled) {\n            this._setScrollEnabled(scrollEnabled);\n        }\n\n        if (interpolators.length !== itemsLength || hasNewSliderWidth ||\n            hasNewSliderHeight || hasNewItemWidth || hasNewItemHeight) {\n            this._activeItem = nextActiveItem;\n            this._previousItemsLength = itemsLength;\n\n            this._initPositionsAndInterpolators(this.props);\n\n            // Handle scroll issue when dynamically removing items (see #133)\n            // This also fixes first item's active state on Android\n            // Because 'initialScrollIndex' apparently doesn't trigger scroll\n            if (this._previousItemsLength > itemsLength) {\n                this._hackActiveSlideAnimation(nextActiveItem, null, true);\n            }\n\n            if (hasNewSliderWidth || hasNewSliderHeight || hasNewItemWidth || hasNewItemHeight) {\n                this._snapToItem(nextActiveItem, false, false, false, false);\n            }\n        } else if (nextFirstItem !== this._previousFirstItem && nextFirstItem !== this._activeItem) {\n            this._activeItem = nextFirstItem;\n            this._previousFirstItem = nextFirstItem;\n            this._snapToItem(nextFirstItem, false, true, false, false);\n        }\n\n        if (this.props.onScroll !== prevProps.onScroll) {\n          this._setScrollHandler(this.props);\n        }\n    }\n\n    componentWillUnmount () {\n        this._mounted = false;\n        this.stopAutoplay();\n        clearTimeout(this._apparitionTimeout);\n        clearTimeout(this._hackSlideAnimationTimeout);\n        clearTimeout(this._enableAutoplayTimeout);\n        clearTimeout(this._autoplayTimeout);\n        clearTimeout(this._snapNoMomentumTimeout);\n        clearTimeout(this._edgeItemTimeout);\n        clearTimeout(this._lockScrollTimeout);\n    }\n\n    get realIndex () {\n        return this._activeItem;\n    }\n\n    get currentIndex () {\n        return this._getDataIndex(this._activeItem);\n    }\n\n    get currentScrollPosition () {\n        return this._currentContentOffset;\n    }\n\n    _setScrollHandler(props) {\n      // Native driver for scroll events\n      const scrollEventConfig = {\n        listener: this._onScroll,\n        useNativeDriver: true,\n      };\n      this._scrollPos = new Animated.Value(0);\n      const argMapping = props.vertical\n        ? [{ nativeEvent: { contentOffset: { y: this._scrollPos } } }]\n        : [{ nativeEvent: { contentOffset: { x: this._scrollPos } } }];\n\n      if (props.onScroll && Array.isArray(props.onScroll._argMapping)) {\n        // Because of a react-native issue https://github.com/facebook/react-native/issues/13294\n        argMapping.pop();\n        const [ argMap ] = props.onScroll._argMapping;\n        if (argMap && argMap.nativeEvent && argMap.nativeEvent.contentOffset) {\n          // Shares the same animated value passed in props\n          this._scrollPos =\n            argMap.nativeEvent.contentOffset.x ||\n            argMap.nativeEvent.contentOffset.y ||\n            this._scrollPos;\n        }\n        argMapping.push(...props.onScroll._argMapping);\n      }\n      this._onScrollHandler = Animated.event(\n        argMapping,\n        scrollEventConfig\n      );\n    }\n\n    _needsScrollView () {\n        const { useScrollView } = this.props;\n        return useScrollView || !AnimatedFlatList || this._shouldUseStackLayout() || this._shouldUseTinderLayout();\n    }\n\n    _needsRTLAdaptations () {\n        const { vertical } = this.props;\n        return IS_RTL && !IS_IOS && !vertical;\n    }\n\n    _canLockScroll () {\n        const { scrollEnabled, enableMomentum, lockScrollWhileSnapping } = this.props;\n        return scrollEnabled && !enableMomentum && lockScrollWhileSnapping;\n    }\n\n    _enableLoop () {\n        const { data, enableSnap, loop } = this.props;\n        return enableSnap && loop && data && data.length && data.length > 1;\n    }\n\n    _shouldAnimateSlides (props = this.props) {\n        const { inactiveSlideOpacity, inactiveSlideScale, scrollInterpolator, slideInterpolatedStyle } = props;\n        return inactiveSlideOpacity < 1 ||\n            inactiveSlideScale < 1 ||\n            !!scrollInterpolator ||\n            !!slideInterpolatedStyle ||\n            this._shouldUseShiftLayout() ||\n            this._shouldUseStackLayout() ||\n            this._shouldUseTinderLayout();\n    }\n\n    _shouldUseCustomAnimation () {\n        const { activeAnimationOptions } = this.props;\n        return !!activeAnimationOptions && !this._shouldUseStackLayout() && !this._shouldUseTinderLayout();\n    }\n\n    _shouldUseShiftLayout () {\n        const { inactiveSlideShift, layout } = this.props;\n        return layout === 'default' && inactiveSlideShift !== 0;\n    }\n\n    _shouldUseStackLayout () {\n        return this.props.layout === 'stack';\n    }\n\n    _shouldUseTinderLayout () {\n        return this.props.layout === 'tinder';\n    }\n\n    _getCustomData (props = this.props) {\n        const { data, loopClonesPerSide } = props;\n        const dataLength = data && data.length;\n\n        if (!dataLength) {\n            return [];\n        }\n\n        if (!this._enableLoop()) {\n            return data;\n        }\n\n        let previousItems = [];\n        let nextItems = [];\n\n        if (loopClonesPerSide > dataLength) {\n            const dataMultiplier = Math.floor(loopClonesPerSide / dataLength);\n            const remainder = loopClonesPerSide % dataLength;\n\n            for (let i = 0; i < dataMultiplier; i++) {\n                previousItems.push(...data);\n                nextItems.push(...data);\n            }\n\n            previousItems.unshift(...data.slice(-remainder));\n            nextItems.push(...data.slice(0, remainder));\n        } else {\n            previousItems = data.slice(-loopClonesPerSide);\n            nextItems = data.slice(0, loopClonesPerSide);\n        }\n\n        return previousItems.concat(data, nextItems);\n    }\n\n    _getCustomDataLength (props = this.props) {\n        const { data, loopClonesPerSide } = props;\n        const dataLength = data && data.length;\n\n        if (!dataLength) {\n            return 0;\n        }\n\n        return this._enableLoop() ? dataLength + (2 * loopClonesPerSide) : dataLength;\n    }\n\n    _getCustomIndex (index, props = this.props) {\n        const itemsLength = this._getCustomDataLength(props);\n\n        if (!itemsLength || (!index && index !== 0)) {\n            return 0;\n        }\n\n        return this._needsRTLAdaptations() ? itemsLength - index - 1 : index;\n    }\n\n    _getDataIndex (index) {\n        const { data, loopClonesPerSide } = this.props;\n        const dataLength = data && data.length;\n\n        if (!this._enableLoop() || !dataLength) {\n            return index;\n        }\n\n        if (index >= dataLength + loopClonesPerSide) {\n            return loopClonesPerSide > dataLength ?\n                (index - loopClonesPerSide) % dataLength :\n                index - dataLength - loopClonesPerSide;\n        } else if (index < loopClonesPerSide) {\n            // TODO: is there a simpler way of determining the interpolated index?\n            if (loopClonesPerSide > dataLength) {\n                const baseDataIndexes = [];\n                const dataIndexes = [];\n                const dataMultiplier = Math.floor(loopClonesPerSide / dataLength);\n                const remainder = loopClonesPerSide % dataLength;\n\n                for (let i = 0; i < dataLength; i++) {\n                    baseDataIndexes.push(i);\n                }\n\n                for (let j = 0; j < dataMultiplier; j++) {\n                    dataIndexes.push(...baseDataIndexes);\n                }\n\n                dataIndexes.unshift(...baseDataIndexes.slice(-remainder));\n                return dataIndexes[index];\n            } else {\n                return index + dataLength - loopClonesPerSide;\n            }\n        } else {\n            return index - loopClonesPerSide;\n        }\n    }\n\n    // Used with `snapToItem()` and 'PaginationDot'\n    _getPositionIndex (index) {\n        const { loop, loopClonesPerSide } = this.props;\n        return loop ? index + loopClonesPerSide : index;\n    }\n\n    _getFirstItem (index, props = this.props) {\n        const { loopClonesPerSide } = props;\n        const itemsLength = this._getCustomDataLength(props);\n\n        if (!itemsLength || index > itemsLength - 1 || index < 0) {\n            return 0;\n        }\n\n        return this._enableLoop() ? index + loopClonesPerSide : index;\n    }\n\n    _getWrappedRef () {\n        if (this._carouselRef && (\n            (this._needsScrollView() && this._carouselRef.scrollTo) ||\n            (!this._needsScrollView() && this._carouselRef.scrollToOffset)\n        )) {\n            return this._carouselRef;\n        }\n        // https://github.com/facebook/react-native/issues/10635\n        // https://stackoverflow.com/a/48786374/8412141\n        return this._carouselRef && this._carouselRef.getNode && this._carouselRef.getNode();\n    }\n\n    _getScrollEnabled () {\n        return this._scrollEnabled;\n    }\n\n    _setScrollEnabled (scrollEnabled = true) {\n        const wrappedRef = this._getWrappedRef();\n\n        if (!wrappedRef || !wrappedRef.setNativeProps) {\n            return;\n        }\n\n        // 'setNativeProps()' is used instead of 'setState()' because the latter\n        // really takes a toll on Android behavior when momentum is disabled\n        wrappedRef.setNativeProps({ scrollEnabled });\n        this._scrollEnabled = scrollEnabled;\n    }\n\n    _getKeyExtractor (item, index) {\n        return this._needsScrollView() ? `scrollview-item-${index}` : `flatlist-item-${index}`;\n    }\n\n    _getScrollOffset (event) {\n        const { vertical } = this.props;\n        return (event && event.nativeEvent && event.nativeEvent.contentOffset &&\n            event.nativeEvent.contentOffset[vertical ? 'y' : 'x']) || 0;\n    }\n\n    _getContainerInnerMargin (opposite = false) {\n        const { sliderWidth, sliderHeight, itemWidth, itemHeight, vertical, activeSlideAlignment } = this.props;\n\n        if ((activeSlideAlignment === 'start' && !opposite) ||\n            (activeSlideAlignment === 'end' && opposite)) {\n            return 0;\n        } else if ((activeSlideAlignment === 'end' && !opposite) ||\n            (activeSlideAlignment === 'start' && opposite)) {\n            return vertical ? sliderHeight - itemHeight : sliderWidth - itemWidth;\n        } else {\n            return vertical ? (sliderHeight - itemHeight) / 2 : (sliderWidth - itemWidth) / 2;\n        }\n    }\n\n    _getViewportOffset () {\n        const { sliderWidth, sliderHeight, itemWidth, itemHeight, vertical, activeSlideAlignment } = this.props;\n\n        if (activeSlideAlignment === 'start') {\n            return vertical ? itemHeight / 2 : itemWidth / 2;\n        } else if (activeSlideAlignment === 'end') {\n            return vertical ?\n                sliderHeight - (itemHeight / 2) :\n                sliderWidth - (itemWidth / 2);\n        } else {\n            return vertical ? sliderHeight / 2 : sliderWidth / 2;\n        }\n    }\n\n    _getCenter (offset) {\n        return offset + this._getViewportOffset() - this._getContainerInnerMargin();\n    }\n\n    _getActiveItem (offset) {\n        const { activeSlideOffset, swipeThreshold } = this.props;\n        const center = this._getCenter(offset);\n        const centerOffset = activeSlideOffset || swipeThreshold;\n\n        for (let i = 0; i < this._positions.length; i++) {\n            const { start, end } = this._positions[i];\n            if (center + centerOffset >= start && center - centerOffset <= end) {\n                return i;\n            }\n        }\n\n        const lastIndex = this._positions.length - 1;\n        if (this._positions[lastIndex] && center - centerOffset > this._positions[lastIndex].end) {\n            return lastIndex;\n        }\n\n        return 0;\n    }\n\n    _initPositionsAndInterpolators (props = this.props) {\n        const { data, itemWidth, itemHeight, scrollInterpolator, vertical } = props;\n        const sizeRef = vertical ? itemHeight : itemWidth;\n\n        if (!data || !data.length) {\n            return;\n        }\n\n        let interpolators = [];\n        this._positions = [];\n\n        this._getCustomData(props).forEach((itemData, index) => {\n            const _index = this._getCustomIndex(index, props);\n            let animatedValue;\n\n            this._positions[index] = {\n                start: index * sizeRef,\n                end: index * sizeRef + sizeRef\n            };\n\n            if (!this._shouldAnimateSlides(props)) {\n                animatedValue = new Animated.Value(1);\n            } else if (this._shouldUseCustomAnimation()) {\n                animatedValue = new Animated.Value(_index === this._activeItem ? 1 : 0);\n            } else {\n                let interpolator;\n\n                if (scrollInterpolator) {\n                    interpolator = scrollInterpolator(_index, props);\n                } else if (this._shouldUseStackLayout()) {\n                    interpolator = stackScrollInterpolator(_index, props);\n                } else if (this._shouldUseTinderLayout()) {\n                    interpolator = tinderScrollInterpolator(_index, props);\n                }\n\n                if (!interpolator || !interpolator.inputRange || !interpolator.outputRange) {\n                    interpolator = defaultScrollInterpolator(_index, props);\n                }\n\n                animatedValue = this._scrollPos.interpolate({\n                    ...interpolator,\n                    extrapolate: 'clamp'\n                });\n            }\n\n            interpolators.push(animatedValue);\n        });\n\n        this.setState({ interpolators });\n    }\n\n    _getSlideAnimation (index, toValue) {\n        const { interpolators } = this.state;\n        const { activeAnimationType, activeAnimationOptions } = this.props;\n\n        const animatedValue = interpolators && interpolators[index];\n\n        if (!animatedValue && animatedValue !== 0) {\n            return null;\n        }\n\n        const animationCommonOptions = {\n            isInteraction: false,\n            useNativeDriver: true,\n            ...activeAnimationOptions,\n            toValue: toValue\n        };\n\n        return Animated.parallel([\n            Animated['timing'](\n                animatedValue,\n                { ...animationCommonOptions, easing: Easing.linear }\n            ),\n            Animated[activeAnimationType](\n                animatedValue,\n                { ...animationCommonOptions }\n            )\n        ]);\n    }\n\n    _playCustomSlideAnimation (current, next) {\n        const { interpolators } = this.state;\n        const itemsLength = this._getCustomDataLength();\n        const _currentIndex = this._getCustomIndex(current);\n        const _currentDataIndex = this._getDataIndex(_currentIndex);\n        const _nextIndex = this._getCustomIndex(next);\n        const _nextDataIndex = this._getDataIndex(_nextIndex);\n        let animations = [];\n\n        // Keep animations in sync when looping\n        if (this._enableLoop()) {\n            for (let i = 0; i < itemsLength; i++) {\n                if (this._getDataIndex(i) === _currentDataIndex && interpolators[i]) {\n                    animations.push(this._getSlideAnimation(i, 0));\n                } else if (this._getDataIndex(i) === _nextDataIndex && interpolators[i]) {\n                    animations.push(this._getSlideAnimation(i, 1));\n                }\n            }\n        } else {\n            if (interpolators[current]) {\n                animations.push(this._getSlideAnimation(current, 0));\n            }\n            if (interpolators[next]) {\n                animations.push(this._getSlideAnimation(next, 1));\n            }\n        }\n\n        Animated.parallel(animations, { stopTogether: false }).start();\n    }\n\n    _hackActiveSlideAnimation (index, goTo, force = false) {\n        const { data } = this.props;\n\n        if (!this._mounted || !this._carouselRef || !this._positions[index] || (!force && this._enableLoop())) {\n            return;\n        }\n\n        const offset = this._positions[index] && this._positions[index].start;\n\n        if (!offset && offset !== 0) {\n            return;\n        }\n\n        const itemsLength = data && data.length;\n        const direction = goTo || itemsLength === 1 ? 'start' : 'end';\n\n        this._scrollTo(offset + (direction === 'start' ? -1 : 1), false);\n\n        clearTimeout(this._hackSlideAnimationTimeout);\n        this._hackSlideAnimationTimeout = setTimeout(() => {\n            this._scrollTo(offset, false);\n        }, 50); // works randomly when set to '0'\n    }\n\n    _lockScroll () {\n        const { lockScrollTimeoutDuration } = this.props;\n        clearTimeout(this._lockScrollTimeout);\n        this._lockScrollTimeout = setTimeout(() => {\n            this._releaseScroll();\n        }, lockScrollTimeoutDuration);\n        this._setScrollEnabled(false);\n    }\n\n    _releaseScroll () {\n        clearTimeout(this._lockScrollTimeout);\n        this._setScrollEnabled(true);\n    }\n\n    _repositionScroll (index) {\n        const { data, loopClonesPerSide } = this.props;\n        const dataLength = data && data.length;\n\n        if (!this._enableLoop() || !dataLength ||\n            (index >= loopClonesPerSide && index < dataLength + loopClonesPerSide)) {\n            return;\n        }\n\n        let repositionTo = index;\n\n        if (index >= dataLength + loopClonesPerSide) {\n            repositionTo = index - dataLength;\n        } else if (index < loopClonesPerSide) {\n            repositionTo = index + dataLength;\n        }\n\n        this._snapToItem(repositionTo, false, false, false, false);\n    }\n\n    _scrollTo (offset, animated = true) {\n        const { vertical } = this.props;\n        const wrappedRef = this._getWrappedRef();\n\n        if (!this._mounted || !wrappedRef) {\n            return;\n        }\n\n        const specificOptions = this._needsScrollView() ? {\n            x: vertical ? 0 : offset,\n            y: vertical ? offset : 0\n        } : {\n            offset\n        };\n        const options = {\n            ...specificOptions,\n            animated\n        };\n\n        if (this._needsScrollView()) {\n            wrappedRef.scrollTo(options);\n        } else {\n            wrappedRef.scrollToOffset(options);\n        }\n    }\n\n    _onScroll (event) {\n        const { callbackOffsetMargin, enableMomentum, onScroll } = this.props;\n\n        const scrollOffset = event ? this._getScrollOffset(event) : this._currentContentOffset;\n        const nextActiveItem = this._getActiveItem(scrollOffset);\n        const itemReached = nextActiveItem === this._itemToSnapTo;\n        const scrollConditions =\n            scrollOffset >= this._scrollOffsetRef - callbackOffsetMargin &&\n            scrollOffset <= this._scrollOffsetRef + callbackOffsetMargin;\n\n        this._currentContentOffset = scrollOffset;\n        this._onScrollTriggered = true;\n        this._lastScrollDate = Date.now();\n\n        if (this._activeItem !== nextActiveItem && this._shouldUseCustomAnimation()) {\n            this._playCustomSlideAnimation(this._activeItem, nextActiveItem);\n        }\n\n        if (enableMomentum) {\n            clearTimeout(this._snapNoMomentumTimeout);\n\n            if (this._activeItem !== nextActiveItem) {\n                this._activeItem = nextActiveItem;\n            }\n\n            if (itemReached) {\n                if (this._canFireBeforeCallback) {\n                    this._onBeforeSnap(this._getDataIndex(nextActiveItem));\n                }\n\n                if (scrollConditions && this._canFireCallback) {\n                    this._onSnap(this._getDataIndex(nextActiveItem));\n                }\n            }\n        } else if (this._activeItem !== nextActiveItem && itemReached) {\n            if (this._canFireBeforeCallback) {\n                this._onBeforeSnap(this._getDataIndex(nextActiveItem));\n            }\n\n            if (scrollConditions) {\n                this._activeItem = nextActiveItem;\n\n                if (this._canLockScroll()) {\n                    this._releaseScroll();\n                }\n\n                if (this._canFireCallback) {\n                    this._onSnap(this._getDataIndex(nextActiveItem));\n                }\n            }\n        }\n\n        if (nextActiveItem === this._itemToSnapTo &&\n            scrollOffset === this._scrollOffsetRef) {\n            this._repositionScroll(nextActiveItem);\n        }\n\n        if (typeof onScroll === \"function\" && event) {\n            onScroll(event);\n        }\n    }\n\n    _onStartShouldSetResponderCapture (event) {\n        const { onStartShouldSetResponderCapture } = this.props;\n\n        if (onStartShouldSetResponderCapture) {\n            onStartShouldSetResponderCapture(event);\n        }\n\n        return this._getScrollEnabled();\n    }\n\n    _onTouchStart () {\n        const { onTouchStart } = this.props\n\n        // `onTouchStart` is fired even when `scrollEnabled` is set to `false`\n        if (this._getScrollEnabled() !== false && this._autoplaying) {\n            this.pauseAutoPlay();\n        }\n\n        if (onTouchStart) {\n            onTouchStart()\n        }\n    }\n\n    _onTouchEnd () {\n        const { onTouchEnd } = this.props\n\n        if (this._getScrollEnabled() !== false && this._autoplay && !this._autoplaying) {\n            // This event is buggy on Android, so a fallback is provided in _onScrollEnd()\n            this.startAutoplay();\n        }\n\n        if (onTouchEnd) {\n            onTouchEnd()\n        }\n    }\n\n    // Used when `enableSnap` is ENABLED\n    _onScrollBeginDrag (event) {\n        const { onScrollBeginDrag } = this.props;\n\n        if (!this._getScrollEnabled()) {\n            return;\n        }\n\n        this._scrollStartOffset = this._getScrollOffset(event);\n        this._scrollStartActive = this._getActiveItem(this._scrollStartOffset);\n        this._ignoreNextMomentum = false;\n        // this._canFireCallback = false;\n\n        if (onScrollBeginDrag) {\n            onScrollBeginDrag(event);\n        }\n    }\n\n    // Used when `enableMomentum` is DISABLED\n    _onScrollEndDrag (event) {\n        const { onScrollEndDrag } = this.props;\n\n        if (this._carouselRef) {\n            this._onScrollEnd && this._onScrollEnd();\n        }\n\n        if (onScrollEndDrag) {\n            onScrollEndDrag(event);\n        }\n    }\n\n    // Used when `enableMomentum` is ENABLED\n    _onMomentumScrollEnd (event) {\n        const { onMomentumScrollEnd } = this.props;\n\n        if (this._carouselRef) {\n            this._onScrollEnd && this._onScrollEnd();\n        }\n\n        if (onMomentumScrollEnd) {\n            onMomentumScrollEnd(event);\n        }\n    }\n\n    _onScrollEnd (event) {\n        const { autoplayDelay, enableSnap } = this.props;\n\n        if (this._ignoreNextMomentum) {\n            // iOS fix\n            this._ignoreNextMomentum = false;\n            return;\n        }\n\n        if (this._currentContentOffset === this._scrollEndOffset) {\n            return;\n        }\n\n        this._scrollEndOffset = this._currentContentOffset;\n        this._scrollEndActive = this._getActiveItem(this._scrollEndOffset);\n\n        if (enableSnap) {\n            this._snapScroll(this._scrollEndOffset - this._scrollStartOffset);\n        }\n\n        // The touchEnd event is buggy on Android, so this will serve as a fallback whenever needed\n        // https://github.com/facebook/react-native/issues/9439\n        if (this._autoplay && !this._autoplaying) {\n            clearTimeout(this._enableAutoplayTimeout);\n            this._enableAutoplayTimeout = setTimeout(() => {\n                this.startAutoplay();\n            }, autoplayDelay + 50);\n        }\n    }\n\n    // Due to a bug, this event is only fired on iOS\n    // https://github.com/facebook/react-native/issues/6791\n    // it's fine since we're only fixing an iOS bug in it, so ...\n    _onTouchRelease (event) {\n        const { enableMomentum } = this.props;\n\n        if (enableMomentum && IS_IOS) {\n            clearTimeout(this._snapNoMomentumTimeout);\n            this._snapNoMomentumTimeout = setTimeout(() => {\n                this._snapToItem(this._activeItem);\n            }, 100);\n        }\n    }\n\n    _onLayout (event) {\n        const { onLayout } = this.props;\n\n        // Prevent unneeded actions during the first 'onLayout' (triggered on init)\n        if (this._onLayoutInitDone) {\n            this._initPositionsAndInterpolators();\n            this._snapToItem(this._activeItem, false, false, false, false);\n        } else {\n            this._onLayoutInitDone = true;\n        }\n\n        if (onLayout) {\n            onLayout(event);\n        }\n    }\n\n    _snapScroll (delta) {\n        const { swipeThreshold } = this.props;\n\n        // When using momentum and releasing the touch with\n        // no velocity, scrollEndActive will be undefined (iOS)\n        if (!this._scrollEndActive && this._scrollEndActive !== 0 && IS_IOS) {\n            this._scrollEndActive = this._scrollStartActive;\n        }\n\n        if (this._scrollStartActive !== this._scrollEndActive) {\n            // Snap to the new active item\n            this._snapToItem(this._scrollEndActive);\n        } else {\n            // Snap depending on delta\n            if (delta > 0) {\n                if (delta > swipeThreshold) {\n                    this._snapToItem(this._scrollStartActive + 1);\n                } else {\n                    this._snapToItem(this._scrollEndActive);\n                }\n            } else if (delta < 0) {\n                if (delta < -swipeThreshold) {\n                    this._snapToItem(this._scrollStartActive - 1);\n                } else {\n                    this._snapToItem(this._scrollEndActive);\n                }\n            } else {\n                // Snap to current\n                this._snapToItem(this._scrollEndActive);\n            }\n        }\n    }\n\n    _snapToItem (index, animated = true, fireCallback = true, initial = false, lockScroll = true) {\n        const { enableMomentum, onSnapToItem, onBeforeSnapToItem } = this.props;\n        const itemsLength = this._getCustomDataLength();\n        const wrappedRef = this._getWrappedRef();\n\n        if (!itemsLength || !wrappedRef) {\n            return;\n        }\n\n        if (!index || index < 0) {\n            index = 0;\n        } else if (itemsLength > 0 && index >= itemsLength) {\n            index = itemsLength - 1;\n        }\n\n        if (index !== this._previousActiveItem) {\n            this._previousActiveItem = index;\n\n            // Placed here to allow overscrolling for edges items\n            if (lockScroll && this._canLockScroll()) {\n                this._lockScroll();\n            }\n\n            if (fireCallback) {\n                if (onBeforeSnapToItem) {\n                    this._canFireBeforeCallback = true;\n                }\n\n                if (onSnapToItem) {\n                    this._canFireCallback = true;\n                }\n            }\n        }\n\n        this._itemToSnapTo = index;\n        this._scrollOffsetRef = this._positions[index] && this._positions[index].start;\n        this._onScrollTriggered = false;\n\n        if (!this._scrollOffsetRef && this._scrollOffsetRef !== 0) {\n            return;\n        }\n\n        this._scrollTo(this._scrollOffsetRef, animated);\n\n        this._scrollEndOffset = this._currentContentOffset;\n\n        if (enableMomentum) {\n            // iOS fix, check the note in the constructor\n            if (!initial) {\n                this._ignoreNextMomentum = true;\n            }\n\n            // When momentum is enabled and the user is overscrolling or swiping very quickly,\n            // 'onScroll' is not going to be triggered for edge items. Then callback won't be\n            // fired and loop won't work since the scrollview is not going to be repositioned.\n            // As a workaround, '_onScroll()' will be called manually for these items if a given\n            // condition hasn't been met after a small delay.\n            // WARNING: this is ok only when relying on 'momentumScrollEnd', not with 'scrollEndDrag'\n            if (index === 0 || index === itemsLength - 1) {\n                clearTimeout(this._edgeItemTimeout);\n                this._edgeItemTimeout = setTimeout(() => {\n                    if (!initial && index === this._activeItem && !this._onScrollTriggered) {\n                        this._onScroll();\n                    }\n                }, 250);\n            }\n        }\n    }\n\n    _onBeforeSnap (index) {\n        const { onBeforeSnapToItem } = this.props;\n\n        if (!this._carouselRef) {\n            return;\n        }\n\n        this._canFireBeforeCallback = false;\n        onBeforeSnapToItem && onBeforeSnapToItem(index);\n    }\n\n    _onSnap (index) {\n        const { onSnapToItem } = this.props;\n\n        if (!this._carouselRef) {\n            return;\n        }\n\n        this._canFireCallback = false;\n        onSnapToItem && onSnapToItem(index);\n    }\n\n    startAutoplay () {\n        const { autoplayInterval, autoplayDelay } = this.props;\n        this._autoplay = true;\n\n        if (this._autoplaying) {\n            return;\n        }\n\n        clearTimeout(this._autoplayTimeout);\n        this._autoplayTimeout = setTimeout(() => {\n            this._autoplaying = true;\n            this._autoplayInterval = setInterval(() => {\n                if (this._autoplaying) {\n                    this.snapToNext();\n                }\n            }, autoplayInterval);\n        }, autoplayDelay);\n    }\n\n    pauseAutoPlay () {\n        this._autoplaying = false;\n        clearTimeout(this._autoplayTimeout);\n        clearTimeout(this._enableAutoplayTimeout);\n        clearInterval(this._autoplayInterval);\n    }\n\n    stopAutoplay () {\n        this._autoplay = false;\n        this.pauseAutoPlay();\n    }\n\n    snapToItem (index, animated = true, fireCallback = true) {\n        if (!index || index < 0) {\n            index = 0;\n        }\n\n        const positionIndex = this._getPositionIndex(index);\n\n        if (positionIndex === this._activeItem) {\n            return;\n        }\n\n        this._snapToItem(positionIndex, animated, fireCallback);\n    }\n\n    snapToNext (animated = true, fireCallback = true) {\n        const itemsLength = this._getCustomDataLength();\n\n        let newIndex = this._activeItem + 1;\n        if (newIndex > itemsLength - 1) {\n            if (!this._enableLoop()) {\n                return;\n            }\n            newIndex = 0;\n        }\n        this._snapToItem(newIndex, animated, fireCallback);\n    }\n\n    snapToPrev (animated = true, fireCallback = true) {\n        const itemsLength = this._getCustomDataLength();\n\n        let newIndex = this._activeItem - 1;\n        if (newIndex < 0) {\n            if (!this._enableLoop()) {\n                return;\n            }\n            newIndex = itemsLength - 1;\n        }\n        this._snapToItem(newIndex, animated, fireCallback);\n    }\n\n    // https://github.com/facebook/react-native/issues/1831#issuecomment-231069668\n    triggerRenderingHack (offset) {\n        // Avoid messing with user scroll\n        if (Date.now() - this._lastScrollDate < 500) {\n            return;\n        }\n\n        const scrollPosition = this._currentContentOffset;\n        if (!scrollPosition && scrollPosition !== 0) {\n            return;\n        }\n\n        const scrollOffset = offset || (scrollPosition === 0 ? 1 : -1);\n        this._scrollTo(scrollPosition + scrollOffset, false);\n    }\n\n    _getSlideInterpolatedStyle (index, animatedValue) {\n        const { layoutCardOffset, slideInterpolatedStyle } = this.props;\n\n        if (slideInterpolatedStyle) {\n            return slideInterpolatedStyle(index, animatedValue, this.props);\n        } else if (this._shouldUseTinderLayout()) {\n            return tinderAnimatedStyles(index, animatedValue, this.props, layoutCardOffset);\n        } else if (this._shouldUseStackLayout()) {\n            return stackAnimatedStyles(index, animatedValue, this.props, layoutCardOffset);\n        } else if (this._shouldUseShiftLayout()) {\n            return shiftAnimatedStyles(index, animatedValue, this.props);\n        } else {\n            return defaultAnimatedStyles(index, animatedValue, this.props);\n        }\n    }\n\n    _renderItem ({ item, index }) {\n        const { interpolators } = this.state;\n        const {\n            hasParallaxImages,\n            itemWidth,\n            itemHeight,\n            keyExtractor,\n            renderItem,\n            sliderHeight,\n            sliderWidth,\n            slideStyle,\n            vertical\n        } = this.props;\n\n        const animatedValue = interpolators && interpolators[index];\n\n        if (!animatedValue && animatedValue !== 0) {\n            return null;\n        }\n\n        const animate = this._shouldAnimateSlides();\n        const Component = animate ? Animated.View : View;\n        const animatedStyle = animate ? this._getSlideInterpolatedStyle(index, animatedValue) : {};\n\n        const parallaxProps = hasParallaxImages ? {\n            scrollPosition: this._scrollPos,\n            carouselRef: this._carouselRef,\n            vertical,\n            sliderWidth,\n            sliderHeight,\n            itemWidth,\n            itemHeight\n        } : undefined;\n\n        const mainDimension = vertical ? { height: itemHeight } : { width: itemWidth };\n        const specificProps = this._needsScrollView() ? {\n            key: keyExtractor ? keyExtractor(item, index) : this._getKeyExtractor(item, index)\n        } : {};\n\n        return (\n            <Component style={[mainDimension, slideStyle, animatedStyle]} pointerEvents={'box-none'} {...specificProps}>\n                { renderItem({ item, index }, parallaxProps) }\n            </Component>\n        );\n    }\n\n    _getComponentOverridableProps () {\n        const {\n            enableMomentum,\n            itemWidth,\n            itemHeight,\n            loopClonesPerSide,\n            sliderWidth,\n            sliderHeight,\n            vertical\n        } = this.props;\n\n        const visibleItems = Math.ceil(vertical ?\n            sliderHeight / itemHeight :\n            sliderWidth / itemWidth) + 1;\n        const initialNumPerSide = this._enableLoop() ? loopClonesPerSide : 2;\n        const initialNumToRender = visibleItems + (initialNumPerSide * 2);\n        const maxToRenderPerBatch = 1 + (initialNumToRender * 2);\n        const windowSize = maxToRenderPerBatch;\n\n        const specificProps = !this._needsScrollView() ? {\n            initialNumToRender: initialNumToRender,\n            maxToRenderPerBatch: maxToRenderPerBatch,\n            windowSize: windowSize\n            // updateCellsBatchingPeriod\n        } : {};\n\n        return {\n            decelerationRate: enableMomentum ? 0.9 : 'fast',\n            showsHorizontalScrollIndicator: false,\n            showsVerticalScrollIndicator: false,\n            overScrollMode: 'never',\n            automaticallyAdjustContentInsets: false,\n            directionalLockEnabled: true,\n            pinchGestureEnabled: false,\n            scrollsToTop: false,\n            removeClippedSubviews: !this._needsScrollView(),\n            inverted: this._needsRTLAdaptations(),\n            // renderToHardwareTextureAndroid: true,\n            ...specificProps\n        };\n    }\n\n    _getComponentStaticProps () {\n        const { hideCarousel } = this.state;\n        const {\n            containerCustomStyle,\n            contentContainerCustomStyle,\n            keyExtractor,\n            sliderWidth,\n            sliderHeight,\n            style,\n            vertical\n        } = this.props;\n\n        const containerStyle = [\n            containerCustomStyle || style || {},\n            hideCarousel ? { opacity: 0 } : {},\n            vertical ?\n                { height: sliderHeight, flexDirection: 'column' } :\n                // LTR hack; see https://github.com/facebook/react-native/issues/11960\n                // and https://github.com/facebook/react-native/issues/13100#issuecomment-328986423\n                { width: sliderWidth, flexDirection: this._needsRTLAdaptations() ? 'row-reverse' : 'row' }\n        ];\n        const contentContainerStyle = [\n            vertical ? {\n                paddingTop: this._getContainerInnerMargin(),\n                paddingBottom: this._getContainerInnerMargin(true)\n            } : {\n                paddingLeft: this._getContainerInnerMargin(),\n                paddingRight: this._getContainerInnerMargin(true)\n            },\n            contentContainerCustomStyle || {}\n        ];\n\n        const specificProps = !this._needsScrollView() ? {\n            // extraData: this.state,\n            renderItem: this._renderItem,\n            numColumns: 1,\n            keyExtractor: keyExtractor || this._getKeyExtractor\n        } : {};\n\n        return {\n            ref: c => this._carouselRef = c,\n            data: this._getCustomData(),\n            style: containerStyle,\n            contentContainerStyle: contentContainerStyle,\n            horizontal: !vertical,\n            scrollEventThrottle: 1,\n            onScroll: this._onScrollHandler,\n            onScrollBeginDrag: this._onScrollBeginDrag,\n            onScrollEndDrag: this._onScrollEndDrag,\n            onMomentumScrollEnd: this._onMomentumScrollEnd,\n            onResponderRelease: this._onTouchRelease,\n            onStartShouldSetResponderCapture: this._onStartShouldSetResponderCapture,\n            onTouchStart: this._onTouchStart,\n            onTouchEnd: this._onScrollEnd,\n            onLayout: this._onLayout,\n            ...specificProps\n        };\n    }\n\n    render () {\n        const { data, renderItem, useScrollView } = this.props;\n\n        if (!data || !renderItem) {\n            return null;\n        }\n\n        const props = {\n            ...this._getComponentOverridableProps(),\n            ...this.props,\n            ...this._getComponentStaticProps()\n        };\n\n        const ScrollViewComponent = typeof useScrollView === 'function' ? useScrollView : AnimatedScrollView\n\n        return this._needsScrollView() ? (\n            <ScrollViewComponent {...props}>\n                {\n                    this._getCustomData().map((item, index) => {\n                        return this._renderItem({ item, index });\n                    })\n                }\n            </ScrollViewComponent>\n        ) : (\n            <AnimatedFlatList {...props} />\n        );\n    }\n}\n"]},"metadata":{},"sourceType":"module"}