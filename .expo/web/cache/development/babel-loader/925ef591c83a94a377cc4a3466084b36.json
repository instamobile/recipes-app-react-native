{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[Symbol.iterator](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { lessThan, multiply, sub, add, divide, greaterThan, lessOrEq, eq } from \"../operators\";\nimport invariant from 'fbjs/lib/invariant';\nimport AnimatedNode from \"../core/AnimatedNode\";\nimport { createAnimatedCond as cond } from \"../core/AnimatedCond\";\nimport { createAnimatedFunction as proc } from \"../core/AnimatedFunction\";\nvar interpolateInternalSingleProc = proc(function (value, inS, inE, outS, outE) {\n  var progress = divide(sub(value, inS), sub(inE, inS));\n  var resultForNonZeroRange = add(outS, multiply(progress, sub(outE, outS)));\n  var result = cond(eq(inS, inE), cond(lessOrEq(value, inS), outS, outE), resultForNonZeroRange);\n  return result;\n});\n\nfunction interpolateInternalSingle(value, inputRange, outputRange, offset) {\n  var inS = inputRange[offset];\n  var inE = inputRange[offset + 1];\n  var outS = outputRange[offset];\n  var outE = outputRange[offset + 1];\n  return interpolateInternalSingleProc(value, inS, inE, outS, outE);\n}\n\nfunction interpolateInternal(value, inputRange, outputRange) {\n  var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n  if (inputRange.length - offset === 2) {\n    return interpolateInternalSingle(value, inputRange, outputRange, offset);\n  }\n\n  return cond(lessThan(value, inputRange[offset + 1]), interpolateInternalSingle(value, inputRange, outputRange, offset), interpolateInternal(value, inputRange, outputRange, offset + 1));\n}\n\nexport var Extrapolate = {\n  EXTEND: 'extend',\n  CLAMP: 'clamp',\n  IDENTITY: 'identity'\n};\n\nfunction checkNonDecreasing(name, arr) {\n  for (var i = 1; i < arr.length; ++i) {\n    if (arr[i] instanceof AnimatedNode || arr[i - 1] instanceof AnimatedNode) continue;\n    invariant(arr[i] >= arr[i - 1], '%s must be monotonically non-decreasing. (%s)', name, arr);\n  }\n}\n\nfunction checkMinElements(name, arr) {\n  invariant(arr.length >= 2, '%s must have at least 2 elements. (%s)', name, arr);\n}\n\nfunction checkValidNumbers(name, arr) {\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i] instanceof AnimatedNode || typeof arr[i] !== 'number') continue;\n    invariant(Number.isFinite(arr[i]), '%s cannot include %s. (%s)', name, arr[i], arr);\n  }\n}\n\nfunction convertToRadians(outputRange) {\n  for (var _iterator = _createForOfIteratorHelperLoose(outputRange.entries()), _step; !(_step = _iterator()).done;) {\n    var _ref = _step.value;\n\n    var _ref2 = _slicedToArray(_ref, 2);\n\n    var i = _ref2[0];\n    var value = _ref2[1];\n\n    if (typeof value === 'string' && value.endsWith('deg')) {\n      outputRange[i] = parseFloat(value) * (Math.PI / 180);\n    } else if (typeof value === 'string' && value.endsWith('rad')) {\n      outputRange[i] = parseFloat(value);\n    }\n  }\n}\n\nexport default function interpolate(value, config) {\n  var inputRange = config.inputRange,\n      outputRange = config.outputRange,\n      _config$extrapolate = config.extrapolate,\n      extrapolate = _config$extrapolate === void 0 ? Extrapolate.EXTEND : _config$extrapolate,\n      extrapolateLeft = config.extrapolateLeft,\n      extrapolateRight = config.extrapolateRight;\n  checkMinElements('inputRange', inputRange);\n  checkValidNumbers('inputRange', inputRange);\n  checkMinElements('outputRange', outputRange);\n  checkValidNumbers('outputRange', outputRange);\n  checkNonDecreasing('inputRange', inputRange);\n  invariant(inputRange.length === outputRange.length, 'inputRange and outputRange must be the same length.');\n  convertToRadians(outputRange);\n  var left = extrapolateLeft || extrapolate;\n  var right = extrapolateRight || extrapolate;\n  var output = interpolateInternal(value, inputRange, outputRange);\n\n  if (left === Extrapolate.EXTEND) {} else if (left === Extrapolate.CLAMP) {\n    output = cond(lessThan(value, inputRange[0]), outputRange[0], output);\n  } else if (left === Extrapolate.IDENTITY) {\n    output = cond(lessThan(value, inputRange[0]), value, output);\n  }\n\n  if (right === Extrapolate.EXTEND) {} else if (right === Extrapolate.CLAMP) {\n    output = cond(greaterThan(value, inputRange[inputRange.length - 1]), outputRange[outputRange.length - 1], output);\n  } else if (right === Extrapolate.IDENTITY) {\n    output = cond(greaterThan(value, inputRange[inputRange.length - 1]), value, output);\n  }\n\n  return output;\n}","map":{"version":3,"sources":["interpolate.js"],"names":["createAnimatedCond","createAnimatedFunction","interpolateInternalSingleProc","proc","progress","divide","sub","resultForNonZeroRange","add","multiply","result","cond","eq","lessOrEq","inS","inputRange","inE","offset","outS","outputRange","outE","interpolateInternalSingle","lessThan","interpolateInternal","Extrapolate","EXTEND","CLAMP","IDENTITY","i","arr","invariant","Number","value","parseFloat","Math","extrapolate","extrapolateRight","checkMinElements","checkValidNumbers","checkNonDecreasing","convertToRadians","left","extrapolateLeft","right","output","greaterThan"],"mappings":"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","sourcesContent":["import {\n  lessThan,\n  multiply,\n  sub,\n  add,\n  divide,\n  greaterThan,\n  lessOrEq,\n  eq,\n} from '../operators';\nimport invariant from 'fbjs/lib/invariant';\n\nimport AnimatedNode from '../core/AnimatedNode';\nimport { createAnimatedCond as cond } from '../core/AnimatedCond';\nimport { createAnimatedFunction as proc } from '../core/AnimatedFunction';\n\nconst interpolateInternalSingleProc = proc(function(\n  value,\n  inS,\n  inE,\n  outS,\n  outE\n) {\n  const progress = divide(sub(value, inS), sub(inE, inS));\n  // logic below was made in order to provide a compatibility witn an Animated API\n  const resultForNonZeroRange = add(outS, multiply(progress, sub(outE, outS)));\n  const result = cond(\n    eq(inS, inE),\n    cond(lessOrEq(value, inS), outS, outE),\n    resultForNonZeroRange\n  );\n  return result;\n});\n\nfunction interpolateInternalSingle(value, inputRange, outputRange, offset) {\n  const inS = inputRange[offset];\n  const inE = inputRange[offset + 1];\n  const outS = outputRange[offset];\n  const outE = outputRange[offset + 1];\n  return interpolateInternalSingleProc(value, inS, inE, outS, outE);\n}\n\nfunction interpolateInternal(value, inputRange, outputRange, offset = 0) {\n  if (inputRange.length - offset === 2) {\n    return interpolateInternalSingle(value, inputRange, outputRange, offset);\n  }\n  return cond(\n    lessThan(value, inputRange[offset + 1]),\n    interpolateInternalSingle(value, inputRange, outputRange, offset),\n    interpolateInternal(value, inputRange, outputRange, offset + 1)\n  );\n}\n\nexport const Extrapolate = {\n  EXTEND: 'extend',\n  CLAMP: 'clamp',\n  IDENTITY: 'identity',\n};\n\nfunction checkNonDecreasing(name, arr) {\n  for (let i = 1; i < arr.length; ++i) {\n    // We can't validate animated nodes in JS.\n    if (arr[i] instanceof AnimatedNode || arr[i - 1] instanceof AnimatedNode)\n      continue;\n    invariant(\n      arr[i] >= arr[i - 1],\n      '%s must be monotonically non-decreasing. (%s)',\n      name,\n      arr\n    );\n  }\n}\n\nfunction checkMinElements(name, arr) {\n  invariant(\n    arr.length >= 2,\n    '%s must have at least 2 elements. (%s)',\n    name,\n    arr\n  );\n}\n\nfunction checkValidNumbers(name, arr) {\n  for (let i = 0; i < arr.length; i++) {\n    // We can't validate animated nodes in JS.\n    if (arr[i] instanceof AnimatedNode || typeof arr[i] !== 'number') continue;\n    invariant(\n      Number.isFinite(arr[i]),\n      '%s cannot include %s. (%s)',\n      name,\n      arr[i],\n      arr\n    );\n  }\n}\n\nfunction convertToRadians(outputRange) {\n  for (const [i, value] of outputRange.entries()) {\n    if (typeof value === 'string' && value.endsWith('deg')) {\n      outputRange[i] = parseFloat(value) * (Math.PI / 180);\n    } else if (typeof value === 'string' && value.endsWith('rad')) {\n      outputRange[i] = parseFloat(value);\n    }\n  }\n}\n\nexport default function interpolate(value, config) {\n  const {\n    inputRange,\n    outputRange,\n    extrapolate = Extrapolate.EXTEND,\n    extrapolateLeft,\n    extrapolateRight,\n  } = config;\n\n  checkMinElements('inputRange', inputRange);\n  checkValidNumbers('inputRange', inputRange);\n  checkMinElements('outputRange', outputRange);\n  checkValidNumbers('outputRange', outputRange);\n  checkNonDecreasing('inputRange', inputRange);\n  invariant(\n    inputRange.length === outputRange.length,\n    'inputRange and outputRange must be the same length.'\n  );\n\n  convertToRadians(outputRange);\n  const left = extrapolateLeft || extrapolate;\n  const right = extrapolateRight || extrapolate;\n  let output = interpolateInternal(value, inputRange, outputRange);\n\n  if (left === Extrapolate.EXTEND) {\n  } else if (left === Extrapolate.CLAMP) {\n    output = cond(lessThan(value, inputRange[0]), outputRange[0], output);\n  } else if (left === Extrapolate.IDENTITY) {\n    output = cond(lessThan(value, inputRange[0]), value, output);\n  }\n\n  if (right === Extrapolate.EXTEND) {\n  } else if (right === Extrapolate.CLAMP) {\n    output = cond(\n      greaterThan(value, inputRange[inputRange.length - 1]),\n      outputRange[outputRange.length - 1],\n      output\n    );\n  } else if (right === Extrapolate.IDENTITY) {\n    output = cond(\n      greaterThan(value, inputRange[inputRange.length - 1]),\n      value,\n      output\n    );\n  }\n\n  return output;\n}\n"]},"metadata":{},"sourceType":"module"}